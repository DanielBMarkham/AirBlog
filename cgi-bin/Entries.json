{"records":[{"id":"recD9L6uEBy8CWS8R","fields":{"ID":57,"Authors":["recPwgCd6QGPvd5Fg"],"Title":"Don't Be A Full-Stack Developer. Be A Full-Stack Human","Content":"<div>\n<div class=\"embed-responsive embed-responsive-16by9\">\n<iframe class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/Bsu_MnArYWQ?rel=0\" allowfullscreen></iframe>\n</div>\n<p class=\"figure-caption text-center text-muted\">\nSpecialize, Specialize, Specialize\n</p>\n</div>\n\nSpecialize, *Specialize*, **Specialize**. Want to create content for others to read? Specialize. It's drilled into your head over and over again. Nobody looks for a book on music, but there are a lot of people who might be interested in a book about west-coast rap singers in the early 2000s. The more you specialize, the tighter your niche, the more you can work on appealing to that niche. Tighten your scope to win. Don't boil the ocean. Focus.\n\nLike the real-estate slogan \"Location, location, location\", the mantra of specialization is drilled into our heads over and over again. Want to go to college? Great! What's your major? Want to program computers, become a professional developer? Great! What are you an expert in? Dive deep, otherwise nobody will hire you. In fact, the best way to get a good job as a developer is to pick a few highly-technical areas and do deep-dives, getting enough experience that you become the local go-to person. If you pick the right combination of tech, you've written your ticket to a high-paying development job anywhere in the world.\n\nThat's the best way to get a *good job* as a developer. That's not the best way to become a *good developer*. Recruiters and job ads everywhere know that good developers are usually \"full-stack\" developers. This is a term that didn't exist 10-15 years ago, and \"full-stack developer\" along with \"10x developer\" tends to make people quite angry now, especially developers.\n\nA full-stack developer is a developer that knows the entire process and pieces used to develop technology. They can walk into a room with no technology in it and leave with a working solution that fits customer's needs, from hardware to software and infrastructure. They're generalists, which of course is the opposite of specialists.\n\n\nThe idea of a specializing generalist, or a generalizing specialist in technology development makes a lot of people's heads explode. \"How can you possibly know everything from the quantum world to how server clusters interact?\" one person said. \"If you know a little bit about everything, isn't that the same as knowing nothing about anything important?\", \"I'm only interested in one technology and it's changing so fast I can't keep up with it. How could anyone possibly know 40?\", or \"This is just another way of saying bullshit artist, right?\"\n\nThese are good comments. I think they show a misunderstanding of the full-stack concept. It's perfectly natural since nothing in your life prepares somebody for being one. From early education to college to job seeking to job advancement,  everything, every bit of common wisdom you've been told is specialize, specialize, specialize.\n\nIt's not that it's bad advice. It's just *woefully incomplete* advice. You don't want to be a full-stack developer. You want to be a full-stack human. Developer is just one part of it.\n\nFirst let's talk about what it means to be a developer, or a human for that matter.\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Space Invaders! Woot!](2019-11-SpaceInvaders)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n   Space Invaders\n</figcaption>\n</figure>\n\n## From Star Trek to Teenaged Video Games of Death ##\n\nI was a dumb kid. When I was a little, I watched and loved \"Star Trek\", a 1960s campy Sci-Fi TV show that featured a bold, brave, heroic, and frankly chauvinistic cardboard cut-out of a space ship captain who took his spaceship, The Enterprise, on new adventures every week to planets that somehow always had beautiful women barely wearing clothes in some form of distres.\n\nWhat can I say? I loved it. I loved it so much that I became convinced in my early years that it somehow must be true. Somehow, some way, there were *real* *real* people on a spaceship Enterprise traveling around the galaxy and I as a small child was watching it all on my local TV Station. I was irreconcilable to the truth in this belief, and although in the back of my mind I had a sneaking suspicion that both Star Trek and Santa Claus may be fakes, the more you tried to reason and use logic with me the deeper I retreated into my fantasy.\n\nThen one day while looking at some Star Trek things to buy, I saw wiring diagrams to the communicators they used on the show.\n\nI was seven or eight. I didn't know what wiring diagrams were, I didn't know that I was basically looking at a diagram for a simple AM radio, a *walkie-talkie* we used to call them, but I knew that somehow in all of these intricate diagrams and symbols was finally proof, mathematical proof that I could use to build my own communicator. Who knew? Maybe I could talk to the Star Trek folks? Beam me up, Scotty!\n\nSince I didn't know the things used in the diagram, I did what I was always supposed to do when confronted with mathematical and scientific mystery: I went to the library. There I found a book on introductory to intermediate electronics. It was a troublesome-looking tome of about 300 pages with dense text, lots of algebraic symbols, and plenty of those little wiring diagrams I saw on that Star Trek diagram.\n\nThat day I basically began the pattern I continued to use for the rest of my life with anything that befuddled me that I had to figure out.\n\n- Approach a personal frontier\n- Observe how people and things interact at this frontier\n- Orient myself to how I view things. What's important, what's a given, what should I question, what are my goals, what are others doing, why are they doing it, where can I gain the most by acting\n- Decide on where I want to interact and experiment \n- Act on that decision. Loop if necessary\n- Walk away to a different frontier or go back to observing\n\nI was a silly kid approaching electronics for really dumb reasons. But I sat on that book, I swam through as much as I could trying to fit my limited math into the algebra it was trying to teach me. I observed marking for resistors, formulas for current, and diagrams for simple circuits. I eventually decided that there was nothing I could immediately act on. There was nothing I could do except try to fit more pieces together later with what I'd learned here. One day I would be victorious! So I walked away.\n\nA few years later, as part of a gifted program in school, they asked me what I wanted to work on. Easy! I wanted a computer!\n\nThey gave me a box of wires and electronic components from the local Radio Shack that was called a computer. You connected the wires and got different results: a light, a blinking light, a siren sound, a radio, lots of logic circuits.\n\nYikes! A radio! Just like when I was a little kid! So now, as I went through my little OODA learning loop with my new \"computer\", I finally figured out how that communicator diagram worked. Like the little kid in the movie A Christmas Story, I realized it was just a dumb radio. There was no computer in that box, there was no communicator in that diagram I had seen years ago. Life consisted mostly of a bunch of dumb commercials for other stuff I didn't want.\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Missile Command](2019-11-MissileCommand)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n   Missile Command\n</figcaption>\n</figure>\n\nThen I got my hands on a **real** computer, a Commodore PET, with 4k of memory, and a cassette tape drive to store programs on. It even had a programming language called BASIC! Heck, you could type both lower and upper case characters on that thing. It was amazing. A piece of Star Trek in my own high school library.\n\nThere was only one computer, though, and there were 30 or 40 of us kids who wanted our hands on it, so the nice librarian created a sign-up sheet which was based on the honor system. You wrote your name in for a certain time-slot. During that time you could use the computer. You could also bring along a friend, but no more than two people at a time could sit at the PET. It was an important piece of sophisticated gear, after all.\n\nThere was this one kid, Roland. Roland had red hair, seemed a bit of a loudmouth, and would erase our names and put his own in their place on the list. This caused many of us to hate Roland and wish he were dead. He seemed to think this was funny. He was bigger than us, so we couldn't do much about kit. Such is kid life.\n\nI could not kill Roland. Not that I was a violent person, but I was angry. I could do the next best thing. I could take this hot piece of smokin' electronics and write a game where I could kill Roland on the little screen. Finally, I was using technology to make the world a better place!\n\nSo I wrote a game like Space Invaders or Missile Command, only with little Rolands that came from the sky as upper-case Rs. You moved your gun around on the bottom of the screen and fired using keys on the keyboard. When I started working on the game, you just could move left or right. The space bar fired. Later on, I developed things like smart missiles, invisible Rolands, a hyperspace button, and so on. It was a hoot.\n\nThen something weird happened. As I started developing the game, other nerds at school wanted a copy of it. Those kids were also frustrated with Roland. They wanted payback. So I made two copies of the cassette, one for development and one for the other kids to use. As they played it, I saw what they liked and what they didn't and adapted my game as I continued programming to make it more like they wanted. I had created my first feedback loop of awesomeness. It felt good. Really good.\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Radio Shack Hobby Radio Kit, circa 1981](2019-11-HobbyRadioKit)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n   This is similar to what I was given to use as a \"first computer\"\n</figcaption>\n</figure>\n\nI was using the same old process for learning as I did earlier in my childhood. Because I had approached so many frontiers and walked away after learning from them, I had a lot of little pieces already in place in my mind. So when I needed a cool special effect for when the little Rolands blew up, I was able to go through the manual easily picking up the code. But I wanted something super cool. What I wanted, it turned out, was **Machine Language**. \n\nMachine Language was the super awesome version of programming. It was programming \"next to the metal\" as they say today. You bypassed BASIC and instead provided binary instructions read directly by the Central Processing Unit, or CPU. What was a CPU? Well, looking at these technical diagrams for a Motorola 6502 CPU, it was a bunch of wires and electronic parts and ... holy hell! It was just a super duper complicated version of that communicator diagram or those wires I connected for that dumb gifted program CPU.\n\nI knew this stuff, or rather I knew *enough of this stuff for now*.\n\nDid I dwell on how each piece was put together? I did not. Instead I grabbed the codes I needed for a loop that would make an explosion, coded it, and continued writing my game. After all, I had other nerds to pander to! And we had violence to commit against a common enemy using computers! Life was short, I walked away from 6502 diagrams and got back to mayhem.\n\nSo the *process of learning* was just the same as it was when I was a small child. I started noticing that there were the same *pieces of learning* no matter what I did.\n\n- Actors: people who want something from the context area I'm exploring\n- Goals: Actors have lives, motivations, and viewpoints. Based on that, they have some goals that we shared, like destroying our arch-enemy Roland\n- Context Area: where those actors had goals that created tests I was interested in created a circle called a context area. We learn inside the circle. Outside the circle life went on\n- Substrate (or Supplementals or Rules): Each context area had various rules that applied, a foundation. When I read the electronics book the substrate was math. Math defined how all the symbols interacted on the pages. With the first computer kit, the substrate was discrete electronic components. With the PET, the substrate was the CPU, BASIC language, display, keyboard, and so forth. You worked on top of the substrate in your context area to reach the common goals you had with the actors \n- Structure: The final piece was the work that you did, what you created, as you chose to act in our process loop, you created structure based on all of the other pieces. Maybe the structure you created was a new electronics diagram, or a new flashing light, or a new feature for your computer program. Structure existed to pass these tests representing goals you came up with based on the rules of the substrate you were using. Were you supposed to make the light flash when you clapped your hands using this kit? Then you adjusted the wires in the kit until it demonstrated this behavior you wanted. Did you want a cool explosion effect for this game for the other nerds? Then you coded some machine language until the screen did something everybody thought was cool-looking. Structure can be anything from wires to make a light blink to the text of a science fiction novel. It was logical, virtual structure, not physical pieces of stuff, although it could be. At its heart it was ideas and how they connected.\n\nI never did finish the game. Instead, I keep tweaking at it, having fun in my mock violence. Everybody loved it, including, oddly-enough, Roland himself, who used to spend a lot of time blowing himself up using my game. He did this by erasing our names and taking our computer time, just like he always did.\n\nPeople are weird.\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Learning Stuff](2019-11-LearningStuff)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n   Learning Stuff, Overview\n</figcaption>\n</figure>\n\nIn fact, I never did finish much of anything, instead flirting from one context area to another for most of my young life, interacting enough to get the general gist of how things worked, getting bored, then moving on.\n\nPeople told me this was a bug. I should not be this way. Instead I should follow some pre-arranged set of rules society made for me and \"do something useful\" Be a doctor, be a scientist, be a businessman! You don't really know anything until you spend a great deal of time actually doing it, otherwise you just *think* you know things when you really don't.\n\nThey were both wrong and right. Some things, like math up until the second year of college calculus, or becoming a serious musician, were useful in thousands of other different areas. They were worth spending a lot of time on (in my young opinion). Leadership was like that. Some things, like learning to change the oil on a 1978 Toyota, might be really useful for a day, but not for much longer than that.\n\nThey were wrong because they were repeating what they had been taught, this canard that has been true throughout most of human history until quite recently. Specialize! Whatever you're doing, there's a division of labor. If you can pick a subset or a certain chunk of that work and become really good at it, you'll be super awesome at doing that thing. All of you working together, each a deep expert in that one area, will be impossible to stop when working in unison.\n\nThey were wrong because this attitude of specializing was true for physical things in a physical world, the world humans have lived in throughout time. In virtual worlds, working with knowledge and symbols, *knowledge work is infinitely divisible*. I saw these two worlds separate in real time because I lived it. In 1970 when you wanted to communicate with a fake ship, you had two people and some kind of hand-held radio that looked cool. Each of those people could probably take some wires and make a radio if they needed to. In 2020 if you had two people who wanted to communicate, you could easily come up with 100 specialty areas that might be involved: electronics, signal processing, voice recognition, tcp-ip, networking, microwave towers, packet radio, edge services, CDNs, POPs, mesh protocols. \n\nI could go on, continue to make a huge list, but no matter how big the list I made, you could pick one or two areas and come back in 60 years and have a hundred new specialty areas. Compare. If you had a factory making mops and tried to create specialty areas, you might have six or seven. You'd run out. There are only so many physical parts to a mop. But if you worked in the virtual world, no matter how many pieces you thought you had, they were all just the things you decided to use to solve that problem. You make your own pieces to solve problems, and you can make as many as you want. The number of pieces you make or use are not related at all to the problem like happens in the physical world. I could make a solution for two people talking in an hour or so. Or we could hire ten thousand people and spend the next thousand years working on it. The complexity of the work is not directly related to the goals. It's much more related to the rules you've put on yourself while doing the work, the substrates you choose (or are chosen for you).\n\n## Becoming successful by becoming an expert ##\n\n\"I don't want to be a good team member. I just want to be the best TypeScript programmer I can be.\"\n\nI looked at the young programmer I was teaching and didn't know what to say. He was correct. I made a lot of money early on by picking the right platforms and technologies and then learning them in-depth. Or at least reading all the books and doing all the mental modeling work that others want to do but never get around to it.\n\nHe was wrong in the same way I was wrong. If you head down that path, you end up being the best guy possible in an arbitrary assemblage of stuff people are currently using to solve problems. You just don't get very good at solving problems. Instead you get good at living in other people's models, you get good at being good. You can *be* good, you just can't *create* good.\n\n\"Most books suck. There are too many books around today,\" a famous economist said last week.\n\nHe was making the same point but he thought he was talking about general mediocrity. In his mind, most books are mediocre, simple re-hashes of various simple patterns done over and over again with slightly different language.\n\nIf the is telling you to specialize in order to become popular, make money, and be successful, and we live in an age where you can specialize *ad infinitum*, then yes, most books suck. You can spend a career becoming the master of how the Motorola 65xx series of processors work and not know a thing about how to use them to learn and solve problems. In fact, if you specialize too much, you'll quickly become an obstacle to others trying to learn and solve problems.\n\n## They were right ##\n\nAll of those well-meaning people were wrong when they tried to keep pitching specialization. Yes, it has an important role in marketing, along with certification programs. It has an important role in physical processes. But it easily and quickly becomes counter-productive in actually doing knowledge work unless you understand how learning works.\n\nAll those folks were right when they emphasized spending time actually doing and accomplishing things in these specialty areas. Until you go through the process of approaching through walking away in a certain area, with a bunch of OODA loops in-between, you don't know what you don't know. That is, it's all symbolic and abstract, like that electronics book. Making goals happen teaches you on what's important in that context area.\n\nI quit stuff a lot. You'll probably quit stuff a lot too. I sure hope so. But if you approach a new context area, interact with it, creating structures inside that circle to achieve your own goals and then walk away, you're learning. Doesn't matter whether that context area is selling books door-to-door or being the best tank you can be on your favorite MMORPG.\n\nYou have to go through the process a lot, you have to interact in a lot of circles, you have to specialize in specializing, become a true generalist, because there's a life critical lesson in there that you're not going to get any other way: each time you draw the circle and set up the structures on the substrate to meet your goals, the structures you set up are mostly arbitrary, even if they have the same names as structures in somebody else's circle. Everything is bullshit, but it still works anyway.\n\nMaking a Customer Management System? Cool! Can you use your \"Customer\" components in somebody else's program? Probably not. In fact, never. **Is this a problem of technology?** No! The \"Customer\" pieces you use and create to fix your problem are based on your interactions, your actors, your goals, and your substrate. The technology is just part of the substrate, and that's a small part of the solution. Your customer won't be my customer and my customer won't be somebody else's customer. But they all have the same English name \"customer\"\n\nSpoken language is a game where we use the same sounds to mean all sorts of vague and ill-defined things.\n\nThe process you go through when you learn and apply that knowledge, creating those structures, gives terms meaning for purposes of that context area. I walked in to my adventure in building a Star Trek communicator with some simple, child-like, mystical idea of what a communicator was. With each interaction I had of how technology works I was left with different ideas of what the terms meant. For a long time I thought there was some universal meaning for everything, perhaps found in a dictionary. This is what they teach you in school, in books. This was the factory model applied to learning: big words are defined using smaller words, like a giant pyramid.\n\nDifferent circles, different people, different goals, different structures, different substrates...all with overlapping and overloaded terms. That's not confusing, that's existing. Words don't exist in a pyramid, they exist in a fuzzy web of half-meanings and kinda-works-here. What you learn by becoming a generalist is that we all create those meanings as we go along whether we realize it or not.\n\nIt doesn't make sense, but it works, we can interact and do useful stuff. People aren't robots. Not even close.\n\nIn fact, being a full-stack developer is an attitude, not a specialization skill. It is knowing deep in your heart that you can't understand everything, that there isn't a single everything to understand, that's there's no way you can know in every way possible every piece of what you're doing. Then doing it anyway. It's an attitude of competence and self-assurance bounced against a complex and unknown world full of mysteries and dangers. It's not rational. It works anyway.\n\nRichard Feymann famously said that if you want to truly understand something, understand it enough that you could explain it to a small child. His point wasn't that life and the universe was simple. His point was that in order to explain a concept to a small child, you had to be able to scope out various pieces that weren't important. You could *know* things in any depth you'd like, but you could only manipulate things with a vanishingly small number of axes of complexity, whether you were a child or a physicist. The human brain is a finite resource.\n\nThere is no universal child. Instead, each child comes with a limited number of life experiences and feelings. To explain something to a child is to understand where they are, then draw the people, arrows, circles, structures, and substrate for them, showing them how it all fits together.\n\nThe story of human progress isn't a story of understanding how the blocks fit together at higher and higher resolutions. It isn't a story of people external to our current interest and the things they believe and do. It isn't a story of how people act with one another and with the concepts we run into every day and how we deal with it. It isn't a story of how the substrate of our interactions continues to get more more nuanced and valuable. This last one is important, as that's what progress is. But even the substrate changes depth depending on what circle we've drawn, which people are involved, and what we're trying to do. \n\nEach of these is important. These are all of the parts of knowing. They all come together every day in billions of combinations as we go about our daily lives.\n\nThe story of humanity's progress is not a story of the parts, it's a story of the story, the process. It's the story of broken-ass people, broken in all sorts of unusual, weird, and pedestrian ways, approaching these frontiers, drawing these circles, identifying these people, choosing these substrates, and implementing these structures over and over again, sometimes walking away, sometimes hanging out for a while longer. And if we're really, really, exceptionally good? The structures we build become part of the substrate others might use when they draw their circles, identify their people, and build their structures. We aren't defining reality. Reality is defining us. The fact that we're faced with reality causes us to make choices. Those choices are what we are.\n\nUnderstanding that this is what we're doing, that this dance of learning is part and parcel of the human condition, is a meta skill. It's used everywhere, from heart surgery to carnival acts. These meta skills, just like any other, can be developed and honed over time, allowing a good student to learn anything and everything they want, based on their own life needs at the time.  This is what a full-stack developer is. This is what a full stack human is. It's a human that knows how to *learn*, how to *skim*, how to *construct*, and how to *walk-away*. Then they do that wherever it's needed. A full-stack human doesn't understand everything from the quantum world upwards to the structure of the universe. They know they don't have to. What they do is interact with life, making passionate choices for their own broken-ass human reasons, learning as much as they need in any area and then moving on. This is the art of living life, it's the art we all create whether we realize it or not. It's what makes life worth living. It what makes us useful to other people.\n\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Daniel B. Markham](DanielsSignature)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\nI wrote this\n</figcaption>\n</figure>","Excerpt":"You can't know everything, and that's the beginning of knowing anything","Approved":true,"Categories":["recQbvNMbYGcFSc8z"],"Tags":["rec8Q7Sn8p6DNLNKJ","recLfkSmV5wJby8YI","rec2QDCvagB9knYdM"],"StartDate":"2019-11-24T05:00:00.000Z","Blog":["recCGKQBlTWHqrGCu"],"Questions":["recP7QjaaAmQLGdzy","recaGbPdPpAx6Pmj0","recbHiSxqyBiNiuDv"],"TemplateFile":"Entry3.html"},"createdTime":"2019-11-24T10:56:36.000Z"},{"id":"recCPslNNdg5eB0nI","fields":{"ID":56,"Authors":["recPwgCd6QGPvd5Fg"],"Title":"Optimal Team Sizes By Function","Content":"<div>\n<div class=\"embed-responsive embed-responsive-16by9\">\n<iframe class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/uuXZC4YSqLY?rel=0\" allowfullscreen></iframe>\n</div>\n<p class=\"figure-caption text-center text-muted\">\nGetting started with teams\n</p>\n</div>\n\nWhat is the right size for a team? Are there certain types of work that dictate certain team sizes? If so, why? And if so, what happens if the team is the wrong size for the work being requested?\n\nThese questions don't have rock-solid answers. They're the type of questions sociologists, psychologists, and management theorists will be studying for years to come. But instead of waiting centuries for information to come back, it's still possible to make some general observations about existing types of work and team sizes. After all, we've been doing various kinds of work with teams for hundreds of years. We know some things work and some things don't even if we don't know why. More importantly, now that we have a meta modal of cognition, we can group teams by what they're trying to learn.\n\nWe know, for instance, that when it comes to creativity, isolated people do better than groups of people. Groups of people can definitely come up with more creative things than a single person, but that's only when each of the people somehow prompt the others to be even more creative on their own. Moving from one to more than one person, there's a shift that happens from \"create something you find unique and interesting\" to \"create something other members of the group will find inspirational for their own creativity\" which is not the same thing at all.\n\nSingle-person creativity changes when it moves to group creativity. When a group is being creative, it is being creative for social reasons, either solely internal or for both internal and external reasons. They can be creating to entertain themselves. They can be creating to come up with interactions that affect others in certain ways. Whatever, the learning is social, not personal.\n\nI'm going to call this group creative learning \"Value Discovery\" because there's obviously some social selection criteria at work, whether implied or explicit. This criteria involves some nebulous definition of value that they themselves come up with. So now we have two categories of team learning: sole creator and value discovery. Looking at our Ladder of Civilization, Sole Creator works on the bottom row. Value Discovery works with the middle two rows. Put differently, when you create or learn things on your own, you take your subjective life and try to abstract it in a way you find interesting. When you create or learn things as part of Value Discovery, you take each of your abstract ideas about life, the universe, and everything and bounce them off one another. You're looking for something that pleases everybody together.\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Learning ladder](2019-11-TeamTypes)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n   Types of Teams and What They Do\n</figcaption>\n</figure>\n\nIf you remember, the bottom two rows, Personal and Abstract, are unique to the individual. There's only one, yours. The top two, Conversational and Real, are context dependent. You can be in conversations with lots of folks in various groups. Context is critical. There's also context to consider in the universe. Whether or not there are multiple universes in the same way there are multiple conversational contexts is above my pay grade.\n\nWhat's the right-sized team for Value Discovery? We have plenty of examples: a playwright writing a play, a pair of programmers coding a game, startup founders, a military reconnaissance team, actors performing improv, a writer's room for a major TV series, early local volunteer fire companies. For those whose only conversational audience is themselves, such as a group of college kids knocking back some beers and talking philosophy, it's an easy and quick loop. For those dealing with multiple social groups, learning gets much more complicated because they're trying to make both themselves and others happy. This is where we'll concentrate.\n\nEach of these example Value Discovery groups are paid to enter completely unknown areas, whether it's business, combat, or tragedy, and collectively come up with patterns of interaction that others will find valuable. While there are plenty of tools, and perhaps some best-practices that show up over time, the only pattern is that there's not a pattern. Everything is \"Zero to One\" as a recent book put it. In many ways, they're inventing the art form as they engage in it.\n\nIt's possible, though unusual for single person to do this, so the lower bound is one. What's the upper bound? I'd say around seven people, though that's pushing it. Two to five people seems about right. Numbers above five that succeed are even more unusual than solo winners. If this sounds like your average Scrum team, you might be ahead of the game here.\n\nThat covers rows (Whether the top row, the universe engages in learning or not is also beyond my pay grade), but there are also columns. There are teams that work in the first column, the Qualities, or perceptions of things. These are service teams. Service teams exist to do things you can't or won't do on your own. Their job is you: making you happy. They're done when you're happy. There are highly customized services like coach or consultant, and there are highly standardized services, like lawyer, doctor, or prostitute. Sometimes you are explicitly supposed to be happy. Sometimes you just agree that the service provider knows more than you and that when you are done you are better off than before *in general*, like with a doctor.\n\nNow we have four types of teams starting with the smallest: Sole Creator, Value Discovery, Highly-Customized Services, Highly-Standardized Services. It's still possible to do all of these kinds of work on your own, so our lower bound still remains one. What's the limit on the upper bounds? Well, since the ultimate criteria is how other people perceive of your interactions, the limiting factor has to be the ability to communicate with customers and among team members. Highly-specialized service teams would have a lot of stuff to communicate about, so the internal communication lines would be massive and their numbers would be smaller. Highly-standardized service providers wouldn't need so much cross-chatter, so those teams could scale out further.\n\nHighly-customized service teams sound like your typical corporate technology team, an A-Team, a modern volunteer fire company, or a Jazz Band. There is some structure: we are here to do this general type of work. We do this as a service to the people who interact with us, and we adapt based on how that interaction goes. The optimum size here seems to be between five and ten, with the system working at the extremes around a dozen or so. The larger the group, the more standardized the service provided, the more rote behavior is emphasized, and the less the group is able to lean and adapt. This is by necessity.\n\nHighly-standardized service teams, because of the severe limits placed on what they can do and the types of communication they can have with both the customer and each other, can scale out much further. I'm going to say it's the Dunbar Number divided by 2, say around a 100 or so, but I'm just guessing. Also reasoning by analogy in the way I'm doing it in this essay sucks. Sadly sometimes this is all we have.\n\nIs that it? Nope. We have one more column in our Ladder of Civilization: the second one, or Objects. Teams that learn in the realm of objects are Product Teams. Products are physical things that allow a user to do something that they can't or won't do. Note: a service team does something in place of a customer; if you were a mechanic or had time to clean your house, perhaps you'd do it yourself. A product team creates a thing the customer owns that they use to do things as they desire. They also might use products in ways the producers don't anticipate. No matter how hard I try, I'm never going to grow wings and become a jet, so I buy a jet to allow me to go places. But I might also use my Jet as a smokehouse to make beef jerky. The service is the Uber driver picking me up and taking me to the airport. The Product is the new car in the driveway.\n\nProduct teams have two interesting features. First, they split into the physical part of the work, manufacturing, and the social interaction part of the work, sales and marketing. Second, just like services, they also have highly customized and highly specialized variants. The sizes of the physical part of product teams are limited by the physicality of the things being manufactured. We cannot assign numbers. A good example of a highly-standardized product team is a pizza shop. A good example of a highly-customized product team is an ad-hoc group on fiver.\n\n<table border=1>\n    <thead><tr style=\"font-weight:bold; text-size:larger;\">\n        <td>Team Type</td>\n        <td>Size</td>\n        <td>Sweet Spot</td>\n    </tr></thead>\n    <tbody>\n        <tr>\n        <td>Sole Creator</td>\n        <td>1</td>\n        <td>1</td>\n        </tr>\n        <tr>\n        <td>Value Discovery</td>\n        <td>1-5</td>\n        <td>2-4</td>\n        </tr>\n        <tr>\n        <td>Highly-Customized Service</td>\n        <td>1-12 (?)</td>\n        <td></td>\n        </tr>\n        <tr>\n        <td>Highly-Standardized Service</td>\n        <td>1-??</td>\n        <td></td>\n        </tr>\n        <tr>\n        <td>Highly-Customized Product</td>\n        <td>1-??</td>\n        <td></td>\n        </tr>\n        <tr>\n        <td>Highly-Standardized Product</td>\n        <td>1-??</td>\n        <td></td>\n        </tr>\n        <tr>\n        <td>Memesis</td>\n        <td>1-</td>\n        <td></td>\n        </tr>\n    </tbody>\n</table><br/>\n\n\nFinally I'm adding \"memesis\" to the list, as it's a type of group learning activity that seems to be everywhere, like air. Memesis is our participation in the narrative of life. When we watch a movie, retweet a tweet, listen to the CEO explain next year's goals, read a book review on Amazon, we are experiencing memesis. It's the representation of reality in art such that the art becomes reality for us, if only for a little while. It is a group activity and there are times which teams are set up to do nothing more than mimetic capture, so we have to include it.\n\nGiven these definitions that I've tried to pull as reliably as possible from industry, history, and commerce, what things do we know now we didn't before?\n\nWhat do managers do? It's pretty obvious now. They're service providers, either highly customized or highly standardized depending on what type of management environment they're in. \n\nDo teams only do one type of activity? No. There's a mix of activities. However, and this is important, different kinds of team activities require different kinds of thinking and all of them have hard limits on how many people can effectively work together at the same time. If you don't realize your mindset needs to change, you'll use the wrong tools in the wrong situation.\n\n<div>\n<div class=\"embed-responsive embed-responsive-16by9\">\n<iframe class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/zdRB3DvC0b4?rel=0\" allowfullscreen></iframe>\n</div>\n<p class=\"figure-caption text-center text-muted\">\nRecap\n</p>\n</div>\n\n\nWhat happens when a technology team becomes too large? Well, now we have the answer: it becomes a service team. Too many people in the mix simply cannot perform value discovery, so the game becomes about performing services that make the boss and customer happy. There's nothing else that can happen. With a small team, you might get highly-customized service delivery. With a large team, you're going to get standardized service delivery.\n\nThis is how you end up with everybody doing what they're supposed to be doing and nothing happening. You've created a large standardized service team that is self-validating. Everybody's working for somebody else...and doing the best they can for them.\n\nThis is also why so many programmers want to create programming tools. You get to go back to Value Discovery, you have yourself and maybe a few friends as either collaborators or potential customers, and you get to engage in that wonderful creativity you had before the real world killed it and squashed all of your hopes and dreams like a bug. (kidding! Just kidding!)\n\nNow that we have a working ontology for teams matched to our learning model, our meta-cognition model is fleshing itself out and we can talk about how groups of various sizes learn. We can also talk about what sorts of roles make sense in a highly-dynamic technology company. We can even talk about Artificial Intelligence, maybe come up with a 21st century update to the Turing Test. But that's for a later day.\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Daniel B. Markham](DanielsSignature)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\nI wrote this\n</figcaption>\n</figure>","Excerpt":"With an ontological meta model and a model of learning, we can now start talking about org structure","Approved":true,"Categories":["recQbvNMbYGcFSc8z"],"Tags":["rec8Q7Sn8p6DNLNKJ","recLfkSmV5wJby8YI","recrv9vV7H2K5WayC"],"StartDate":"2019-11-12T11:00:00.000Z","Blog":["recCGKQBlTWHqrGCu"],"Questions":["recbmGBMrftbwj0Va"],"TemplateFile":"Entry3.html"},"createdTime":"2019-11-12T16:11:56.000Z"},{"id":"recCXSr5YOhRPovUx","fields":{"ID":55,"Authors":["recPwgCd6QGPvd5Fg"],"Title":"Much Ado About Nothing","Content":"<div>\n<div class=\"embed-responsive embed-responsive-16by9\">\n<iframe class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/V7IYkgDu3Ko?rel=0\" allowfullscreen></iframe>\n</div>\n<p class=\"figure-caption text-center text-muted\">\nA preview\n</p>\n</div>\n\n## Much Ado About Nothing. Alternate Titles: ##\n#### Never Don't Put No Nulls In No Computer Programs ####\n#### Babies Don't Let Your Apples Grow Up To Be Newtons ####\n#### I fought the void and the void won  ####\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Learning ladder](2019-10-Ladder)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n   How we learn stuff \n</figcaption>\n</figure>\n\n## Babies Don't Need Math ##\n\nWe don't know stuff, and that's fine. Not knowing, then figuring it out? That empty gap we fill? Filling in that gap is the thing that made this amazing modern world we live in.\n\nThe empty, the void, the missing, this drives us. It is at the heart of being a sentient species. Nothing turns out to be everything. Our innate mental ability to handle and manipulate the idea of missing things, things that should be there but aren't, our pleasure in doing so, is what allows us to operate as an independently-intelligent species that works together.\n\nLet's do a thought experiment. Above is a chart called the Ladder of Civilization. It's for my upcoming book about critical path learning at scale. It's the relationship between our inner life and the rest of the universe. Suppose that you're a baby. You live in a close-knit community in an orchard. One day, after you've grown teeth, you're given this *thing*. You can feel it and it feels smooth, round. It has a stem. It has a certain smell. You don't have any words for \"smooth\", \"round\", \"stem\", or \"smell\", but you can observe these qualities anyway using your body. These unique qualities you directly sense? In our chart, we'll call them Subjective Qualities, or just SQ. \n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Baby](2019-10-Baby)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n   Yay! Babies! \n</figcaption>\n</figure>\n\nYou bite into this thing, and it's wonderful! You have now tasted your first apple, although you don't have a word \"apple\". All you know is you had a series of experiences, you behaved a certain way with this thing you can manipulate, and voila! Yummy taste! Nom nom nom!\n\nThen the next day they give you a different object. It has many of the same qualities as the previous day's object, but it's a different color. Might it taste good too? Who knows? So let's give it a shot! (Babies eat everything) Cool beans, sure as heck, it tastes mostly the same.\n\nYou're obviously manipulating this *thing* in order to get that yummy taste, but some things change while other things stay the same as you interact. Hold the apple one way and it looks like this. Hold the apple another way and it looks like that. Squeeze at the stem and it feels hard. Squeeze the middle and it's softer. Some underlying parts of your experience relates to your *sense and interaction*, some relates to the *thing itself*, the object. Your senses and interaction gives you a subjective experience of an *object*. This object exists in a particular way for you and nobody else. It's a Subjective Object. We'll abbreviate Subjective Object as SO.\n\nRight now, even as a baby, you've created your own superstition or religion. Just for this essay, a religion is a belief without evidence that things work a certain way. Grab the thing, bite the thing, feel yummy taste in mouth. Religious superstitions are instinctive or faith-based rules about how the universe works. In this case, since you're a baby and don't know any language, they're pretty subjective. Let's call these SS, for Subjective Supplementals. Supplementals are things we layer on top in order to predict the future. Grab things, bite things, taste good. You will probably come up with many more Subjective Supplementals as a baby. You might believe that if you cry a lot, the light will come on. You will find ways to control that large shape that appears from time to time to give you a bottle. Subjective Supplementals are not rational or irrational. They're non-rational.\n\nThat's your job as baby; coming up with ways to understand and control the universe given incomplete information consisting of senses and behavior. You receive input, you react, and there's a gap, a missing piece where you need to know what to expect next. You naturally fill in that piece given whatever data you have, or you just make stuff up. Whatever. The gap must be filled, and it feels good to do so. Nom nom nom.\n\n<figure class=\"fig4ure\">\n<div class=\"embed-responsive\">\n\n![Human Brain](2019-10-Brain)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n   Yay! Brains!\n</figcaption>\n</figure>\n\nWhat's bugging you, though, is those two different apples (although, remember, you don't know the word \"apple\"). They were the same except for color. They were really mostly the same, weren't they? And if you observed another one with mostly the same shape and mostly the same color, if you bit into that you would expect mostly the same experience, wouldn't you?\n\nThere are some things, some repeated general patterns about senses, behaviors, objects, and rules that are mostly the same. There are some parts about those things that are different. One day they give you this little round orange thing. You behave the same way, biting into it, expecting the same flavor, but instead there's a new flavor. Wow! You don't know the word \"orange\", but you instinctively know that you need to start thinking about how to generalize and separate things, then reason about the generalized thing. You need more than just instinct.\n\nThis creation of generalized and specialized concepts, then reasoning at the general level that you've created is the basis of intelligence. It's called abstraction. It works the same as your subjective life, only it works only in your head. You have Abstract Qualities (AQ), Abstract Objects (AO), and Abstract Supplementals (AS).\n\nAnd this is how you begin developing your own generalized qualities of things, qualities you might call \"color\", \"roundness\", \"smell\", or \"taste\" but you still don't have words yet. Even without words, though, you're able to think about abstract things. Perhaps all round things will result in the taste you had with that apple. But then there's the orange thing that was also round. It had bumps, right? You are forced to create your own categories and generalizations about what's a quality, what's an object, and what you can generally expect to result when you behave a certain way given those abstract qualities and abstract objects.\n\nYou still don't have language, but you're already developing true intelligence. Everything round, smooth, and red that smells this one way will give us the taste of an apple if we bite it. Everything round, a bit lumpy, and orange will give us this other taste. You're using Abstract Qualities(AQ), Abstract Objects (AO), and Abstract Supplementals (AS). In addition, now it becomes obvious that some objects are composed of and connected to other objects, and the way objects compose and relate to one another, which is another type of abstraction, determine how they behave. Abstract Qualities, Abstract Objects, and Abstract Supplementals fall neatly into a graph. Apples have stems. Oranges do not. Or do they? You're constantly updating your abstract mental life based on your subjective experiences. These two systems, Subjective and Abstract, are running all of the time inside all of us. They keep updating and changing. We're completely unaware of them.\n\nAbstraction changes the game significantly. Once you're grouping things together and sorting them apart in various ways, you're creating what's known as an ontology. Like the Dewey Decimal system, an ontology is just a system you've come up with to keep things organized. You're naming stuff. Even without languages. I don't know how it is possible to have names without language, but I know it happens. I suspect it depends on your primary sensory apparatus. Left alone in the wild, a human develops his own grunts or clicks for abstract things.\n\nUsing abstractions, now you can even start speculating that given these abstract qualities, then performing these abstract behaviors with these abstract objects, always results in this kind of abstract result. You do this using something called abduction. Abduction is taking a bunch of information and coming up with what you think the rules are governing it. It's a generalized form of inference. You have taken the first step on the road to science.\n\nYou can even create new abstract things that you've never directly experienced, like a \"stick like object\", that you can use to do other abstract things, like \"get ants out of an anthill and eat them\". Congrats! Now that you can reason abstractly, you can develop tools!\n\nAt this point, you're not just finding holes in your experiences and filling them in, you're finding generalized holes in your own system of meaning. You've begun to climb the ladder of civilization. Feels great to eat those ants, doesn't it?\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![People around table talking](2019-10-Conversation)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    How do we share our inner abstractions so we can do cool stuff together?\n</figcaption>\n</figure>\n\nThe next rung on the ladder comes when we add people. Now those grunts and clicks or other nameless concepts you're thinking about need to be conveyed to others and compared to their grunts and clicks. This requires something called a \"Theory of the Mind\", where you have to start modeling what you believe _other_ people are thinking, so you can communicate better. Watching each other closely for non-verbal clues, you begin to agree on a system of grunts, hoots, clicks, pops, and other sounds to convey abstract ideas. You and your friends? You guys are developing a language.\n\nOnce groups of people started sharing common sounds for abstract concepts, language, things really started taking off for humans. We're almost done with our layers on our chart, but, oddly enough, this is where our story starts. That is, this is where mankind started: with language and small social groups. There's too much to go into here, and this is well-covered ground, but there are some interesting things you need to remember.\n\nOnce we had a shared sound for that round thing, apple, we naturally wondered: what is the \"pure\" version of an \"apple\"? Is there an exemplar of apples, the Platonic Form? Is there a pure, perfect version of an apple that every actual apple imitates? We thought because we had a shared sound, and a mostly-shared experience, there must be some universal thing that we were talking about. It would be like a higher level of abstraction than each of us already had instinctively. Abstractions actually come from inside of each of us, but we couldn't see that, instead we were trying to make our group of people perform as if it were a large, shared brain. We had an abstract idea of apple, why couldn't the group? Why couldn't people just be a big brain?\n\nThe second thing was written languages. You might think that written languages are like spoken languages, only turned into symbols, but you'd be wrong. There are drastic and profound differences between a written language and a spoken one. I'd go so far to argue that spoken languages are the only real languages. A written language is just some artificially-frozen version of an ideal spoken language that a bunch of people can agree to. It's vitally-needed, of course, but it's not a real, living, evolving system of sharing abstractions together. It's not the fluid, dynamic thing we create anytime we interact. Written languages are museums. Spoken languages are bazaars. \n\nFinally, in our search for pure versions of truth and as part of our learning to write, we created geometry and mathematics, where rigid and formal rules exist that show how written symbols can work with one another and transform from one category to another. We learned axioms, formal deduction. We learned to prove things. Yay us!\n\nAll of this came together because working together, we wanted to control our environment. If we could agree on what apples were, and agree on counting, we could agree on how to create an accounting system for apples. Heck, once we've got a written language, numbers and math, we can do most anything!\n\nUntil we got to zero, that is.\n\n## It's about nothing ##\n\nZero was the first big glitch. Up until zero, cardinal numbers were based on a one-to-one activity that anybody could do. Zero was an extremely useful if not critical addition to our number system, but it took our ideas into conflict in subtle ways that we still deal with.\n\nWhat was happening, and this took us a long, long time to figure out, was that humanity was going two different ways at once. As people got together and worked in small groups, they came into _more agreement_ about what sorts of abstractions and specializations made sense in various contexts. For many, this gave the illusion of _total_ agreement. In all honesty there was no way for them to know. The brain isn't designed to communicate at the bandwidth and depth involved to think about synchronicity between hundreds of terms. Whenever people met and discussed any matter in-depth, a dozen or so \"important\" terms could be nailed down enough to exhaust the ability of that group to find any sign of divergence. This gave a great feeling of accomplishment, much like the baby figuring out apples. But like the scintillating grid illusion, while the things we were looking directly at in conversation looked fixed, the things at the periphery wobbled. Surely somebody else was taking care of those.\n\nThe second track was spent pursuing the idea that since we could come into agreement on what things meant (we thought), since we had a way of writing names down, and since we were creating this wonderful new way of thinking that we'll call _formal systems_, or *math*, why don't we apply math to language? Why couldn't we use reason, logic, and math together to arrive at the ultimate truth, to finally find and use these Platonic Forms that must exist somewhere? There is something deeply satisfying about applying logic to human language, a feeling of accomplishment is common. You feel like you're arriving at some great truth. Nom nom nom!\n\nReality was quite kind, as well. If you counted apples one day and did some math, you could count them the same way the next day and get the same answers. It was only as our progress in formal systems found holes, and our creation of various abstract systems drove us to realize that abstraction was always personal while language was always social that mankind began to realize what was going on. For a long time, we refused to believed there was a conversational level of understanding, thinking that a written language combined with formality could take us from personal ideas to absolute truth. It is a powerful illusion. Any time people interact, language is being created and modified. What we wanted to happen was for language to stay fixed so we could use words like a form of geometry. We couldn't see language changing, so we didn't believe it changed, at least not in important ways.\n\nIf you have six apples and you plan on taking away six apples, how many will you have? That doesn't really seem to have an answer, since if there are no apples there's nothing to talk about. We had to come up with zero out of thin air to make it work. We extended the counting system so that we could plan for the future. Negative numbers extended this pattern of extending things as needed. We moved from counting as a one-to-one correspondence to a number system full of abstract symbols that let us reason about quantities without ever having anything.\n\nExtending the number system and the rest of modern mathematics took a long, long time, but creating self-consistent systems happens all of the time in computer programming. It's like creating a new system of math over and over again with each new project. We can use programming to help show the problem we had with both of these tracks, at least for those of us who work in it every day, so let's use it. Programming will help us to continue our journey into missing pieces and the problem of human language.\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Red Apple](2019-10-RedApple)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\nBrother Maynard has counted the apple, and the count of the apple is one\n</figcaption>\n</figure>\n\nLet's say you're writing a program for apple counting. You might start like this:\n\n<pre style=\"font-family:Consolas;font-size:13px;color:black;background:white;\">appleCount&nbsp;=&nbsp;0;\n</pre>\n\nThis makes sense. You start off with no apples. But what, exactly information is being conveyed by this line, not to the computer, but to the reader? There is something called an apple, there is something called a count, and by applying count to apple, there is currently not an answer. Apples do not exist in the bucket we have for them. Is that right?\n\nI don't know. How about this?\n\n<pre style=\"font-family:Consolas;font-size:13px;color:black;background:white;\"><span style=\"color:blue;\">let</span>&nbsp;appleCount=<span style=\"color:blue;\">null</span>\n</pre>\n\nWell now, this is a little different, isn't it? You have the same first two concepts, apples and count, but null implies not that the answer is known and there is no quantity, it implies that there is no answer. It is unitialized, not ready for use.\n\nAre they the same? No, not at all. The first one sets us up in a number system where things like addition and subtraction might be used. The second one just tells us there's a name we might use one day.\n\nHow about this one?\n\n <pre style=\"font-family:Consolas;font-size:13px;color:black;background:white;\"><span style=\"color:blue;\">type</span>&nbsp;HasApples&nbsp;=&nbsp;True&nbsp;|&nbsp;False&nbsp;|&nbsp;NotProvided\n</pre>\n\nNow we're taken out the fact they're counted or not and just want to know if there are any apples there. But perhaps they won't tell us! This is one of my favorite programming constructs, the \"three state binary\"  which drove me nuts back in the day and which I hope I never see again.\n\nIt does wonders for your programming logic.\n\nF# can handle all of the cases, so in F# we can make something like this:\n\n<pre style=\"font-family:Consolas;font-size:13px;color:black;background:white;\"><span style=\"color:blue;\">type</span>&nbsp;AppleCount&nbsp;=&nbsp;Int\n<span style=\"color:blue;\">type</span>&nbsp;CountedApples&nbsp;=&nbsp;False&nbsp;|&nbsp;AppleCount</pre>\n\nThere's something about this code that makes me happy inside. I think it's the fact that it covers so many conditions with just two lines. I have that wonderful common feeling that I know everything. I get that a lot when coding. It's never true. But it's a happy feeling. I have filled in a hole.\n\nThe problem here, of course, is that we're confusing how we got this number that represents the count of apples with the count itself. One is an action; the other is a state. Depending on how the action turns out, we may not know about the state. Many languages have an option type to handle this:\n\n<pre style=\"font-family:Consolas;font-size:13px;color:black;background:white;\"><span style=\"color:blue;\">type</span>&nbsp;AppleCount&nbsp;=&nbsp;option&lt;int&gt;\n</pre>\n\nThis is sort of the ultimate in eating your cake and having it too. Maybe I know about the count of apples, maybe I don't. Don't worry about it. Figure it out when you need it.\n\nThe obvious problem here, of course, is that if you've went to the effort making a variable for the apple count, you did it for a good reason. You need it. If it's not necessary for what you're doing, you shouldn't put it in there. If it is necessary? Something should happen, some important thing, if it's gone. You just can't punt. If you try to delay reasoning about the variable, with any non-trivial number of variables, this becomes the computer programming version of \"I have a secret\" What's this program doing? It has all of these variables with really good names. I don't know. While the names are great, I have no idea what the state is from invocation to invocation. I have been told something in something that looks like English but I am no further along the path to understanding than when I started. In fact, I'm probably much worse off because the words don't match up to my understanding of them.\n\nOnly in computer projects does a ton of documentation indicate serious problems with a specification. A ton of docs is a smell that somebody is trying to use the dictionary and a bunch of templates to beat the vagueness out. Hell, we can't do that using code, we sure as hell can't do it using a written language. We of all people should know that.\n\nBut continuing our coding, we've got both an action and a result. To address this, to separate action and result, we have monads. Here we change things around. It's don't call us, we'll call you. In other words, we'll let you know when we have a count. Monads are just functions we compose into workflows. The general idea is that a small number of functions that do exactly what they say beats a larger number of objects and variables that appear to let us reason about state and behavior but actually do not.\n\nWhat does programming teach us? It teaches us that we can create systems, even provable formal systems, such that our human brain can look at a small part and feel like it's totally understandable, but the system overall still does not behave as expected. We can use highly formal symbols and rigid processes to create a fake understanding. Not only is this possible, it's our special magic trick as humans. We do it over and over again. It feels to us that we are filling in gaps where no actual progress is taking place. Nom nom nom!\n\nOur experiences in life, our sensory input and emotions, the bottom rung of the ladder, are entirely subjective. We own them, and we own them in a way that we can never fully share. Our abstractions about our experiences are things we can label and perhaps one day share with others. As we share with others, all of our abstractions come into somewhat of an alignment through conversation and the dialectic, enough for the early Greeks and later philosophers to feel that we were reaching for some absolute truth, reaching *down* into a key underlying reality, a truth.\n\nWhat we were actually doing was creating a formal system we later called geometry and mathematics, then mapping our shared abstractions to it. As we mapped more and more shared abstractions, it *felt* as if we could map it all; that one day all of human interaction would be math. That is a powerful, powerful siren call. Zero was an early sign that the things we experience, abstract, share, and align on are in a different world than formal systems; that human languages and programming languages are separate things entirely and they will never, ever meet....for very good reasons.\n\nThe story of math, philosophy, and science took centuries. You can write a decently-complicated program in a tiny fraction of that time; end up in the same place.\n\nBy banging our head against the wall over and over again with code, we see that even the simple idea of counting apples can expand out into all kinds of other places, mostly because there is no single, stand-alone idea. Any word only exists as part of an ongoing relationship with other words (h/t Wittgenstein). The count of apples is related to counting. Counting is related to people doing work. The computer forces us to exhaust all of the possibilities, either through our testing or the interaction between the program and the real world. The more we try to handle counting apples, the more complexity ends up in our program. The average computer program has dozens or hundreds of such concepts. This is the reason that how we handle empty, missing, or data-coming-soon is the most important decision we can make while programming. What's the first? Naming, of course! Cache-invalidation is a close third. Cache invalidation is just the creation of supplementals, the desire to predict the future, only applied to data.\n\nWhile this is very clear very quickly in programming, in real life with science and reason it happened quite slowly. After we spent several thousand years developing languages, cultures, religions, and ways to calculate things, it eventually became clear that while we're excellent at working together to accomplish things directly in front of us, we're not so good at staying aligned on a lot of things over any period of time. People have different experiences; their subjective and abstract models are changing all of the time. All three levels, Subjective, Abstract, and Conversational, are constantly running inside each of us. It's innate. (Sidebar: by the way, this is the post-modernist conflict, the acknowledgment that some social groups name and solve problems differently as opposed to others. It's led to the idea that there are different realities, which is nonsense. What there is is a conversational level of language and understanding that is social in nature, not a separate version of reality or facts.)\n\nWe kept thinking that math, or some other kind of formal system, would save us from this chaos. Instead, the more we used formal systems to investigate the unknown, the more it showed us other unknowns. The more we realized how little of what we thought we knew we actually understood.\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![QuestionMark](2019-10-QuestionMark)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n\n</figcaption>\n</figure>\n\n## The Unknown ##\n\nNewton didn't see an apple fall from a tree. The story is apocryphal. There were zero apples that fell from a tree to inspire Newton. But playing loosely with the truth, let's say it's true. When Newton saw zero apples fall from the tree, he realized he had explained gravity, right? Newton discovered the Law of Gravity. Everybody knows that.\n\nBut he did no such thing. This is a generalization you were probably taught growing up. What he did, because he was a genius of a kind only rarely seen on this big old cute lovable mudball we call Earth, is put together a bunch of mathematical symbols to describe how things fall. While superbly neat, he was not happy mainly because *he had absolutely no idea what was going on, simply how to describe it in math*. In the same way that zero can be a very useful concept to work with even if it doesn't correspond to something we can experience, Newton's Law Of Gravity was a very useful concept to use to predict how things will behave even if we have no idea what's going on or any way to directly experience it.\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![The fundamental theorem of calculus](2019-10-FundamentalTheoremOfCalculus)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\nThe Fundamental Theorem of Calculus, or how to find the area under a curve\n</figcaption>\n</figure>\n\nAnd that was just the beginning. The word \"calculus\" simply means a way of calculating. An abacus is a form of calculus. So is Chisanbop, Korean hand math. Newton was famous for inventing The Calculus, the thing that most all modern engineering is based off. (There were plenty of others, mainly Leibniz, that helped, but for now we simplify drastically). Calculus does a lot of things, but one of the main things is give us the area under the curve of a continuous function. How much weight does water press on a dam wall? How can we use orbital slingshot maneuvers to visit planets in the solar system using less fuel?  How might a certain financial instrument be better or worse than another one? These questions are all answered using calculus.\n\nOnce again, just like with zero, we've divorced ourselves from reality in ways that are uncomfortable in order to make the math work and do useful things for us. Is reality continuous? Is there anything in nature that when looked at using extreme magnification, that's a pure curve? Well, we didn't know. We still don't know. We don't know about gravity. We don't know about whether the universe is discrete or continuous. Continuing to chase the math, we've reached the point where we can harness amazing forces, like the nuclear bomb, without really understanding what's going on. We just know enough to work with it. \"Shut up and do the math\" is a catchphrase for many physicists. It's gotten so bad that some physicists are wondering if we just shouldn't keep chasing the math, trying to find a good theory, and not worrying about whether any of it can be proven or not. If the math looks good, why wouldn't it be right? If that code looks good and compiles, we're done, right?\n\nRight?\n\nGodel's Incompleteness Theorem has been used (in error) to explain everything from psychics to aliens, but at the heart it's very simple and not that controversial: any formal system of proofs will have true statements that are unprovable and false statements that cannot be disproved. That means that the math itself has limits. Math, a calculus, is extremely useful, but any particular system of calculation can't be used for everything.\n\nSo even if somehow we eliminated human language and worked only in math, we've still got holes, more zeroes, more empty spots to fill.\n\nIt's as if science, knowledge itself was one giant computer program that mankind had put together over thousands of years. Like any first computer program, we stuck as much stuff as we could in there. We had things that didn't make sense but they worked. We thought we could use this one program for everything. When that didn't work, we created new maths: imaginary numbers, quaternions, octernions, non-euclidean geometry, and so on, eventually generalizing much of it out to Category Theory, which is both a master model of math and a master model of how we'd like computers to operate. No coincidence there.\n\nGodel showed us that no matter what system of calculation we came up with, it was always going to be incomplete and miss things. There would always be a zero, a gap, between what the system did and what we know to be true or false using other systems.\n\n\nOk. We can fix this. So we'll just use multiple systems, right? One system of calculation for one thing, one system for another. This is much the same as when the accounting system you built doesn't work for a particular thing, you'll just buy another; use them both. Then they can integrate....somehow. (There is usually a bit of arm-waving at this point when the salesperson does their pitch) We've had no problem at all integrating General Relativity with Newtonian Physics, right? How's Dark Energy coming along lately? I heard that stuff was for WIMPS!\n\nWe make a mistake when we think we can move directly from our inner abstractions to math without considering the role of conversation and language. We make a similar mistake when we think we can stick with just abstraction and conversation, ignoring math.\n\nLet's assume you've created the ultimate programming system for apples. It works fine and it's been working fine for years. One day you're selling your apples and a man walks by. You ask him if he wants an Apple. He says no thanks, he already has a nice white one.\n\nYou are an expert on apples. You've been around apples all of your life. Apples are not white. You point out to him that apples are red, maybe yellow, and round. He says nope, they're white, and always rectangular.\n\nAfter some confusion, you realize he's talking about an Apple computer, not an eating apple. In our conversations with our fellow apple buddies, we have created our own spoken language around the eating apples. In his conversation with his computer friends, they've also created a language, using some of the same words that you have, but they have a completely different understanding than you do. Even with everything else fixed, there is a difference between communities. Reality doesn't change, but words like \"is\", \"inside\", or \"apple\" can mean completely different things depending on your social group. Our system works, just not for everybody.\n\nWith \"apple\" it's pedantically obvious. In reality it happens in very, very subtle ways. Our various communities are treating spoken words as if they are written words, and written words as if they are mathematical symbols. That's natural, because after all we take whatever we can and work with it inside our minds as abstraction, whether that's a good idea or not. But brains aren't computers, and our cognitive scope is so small that we can fool ourselves into thinking we've covered all of the bases when it comes to writing one line of code. Anything more complicated is even more easy to believe that we know completely when we don't. It's not the big things that get us, the 1+1=2 things. It's the ridiculously ludicrously simple things like \"apple\".\n\n## The Great Unknown ##\n\nWhat happens if we skip the abstraction level, trying to move directly from sensing to language?\n\nWe spent hundreds of years trying to build communities and systems of belief based on written language, with various spectacular failures along the way. Languages are spoken ways to have conversations in small groups to come into alignment about things. Small groups that are in alignment about things can then leverage that alignment to map their knowledge into some mathematical system or computer program. They can then use that system to explore the unknown. We tried that with religion and government, but we can't ignore the fact that each of us is constantly re-jiggering our abstractions based on our subjective life. Your human mind is designed to take a few things and abstract them, guessing wildly what might work and acting on it. You might think you have a mind like a machine, but you do not.\n\nFinally Nietzsche. Nietzsche famously said \"God is dead\". Nobody quotes his next line much. \"And it is we that have killed him\"\n\nHis point was not about whether there was a God or not, at least not in the way people think. His point was that we were spending so much effort trying to create these logically-consistent systems of belief, as if we were making some new calculus or computer program, and it was never going to work, no matter how hard we tried. Bugs or misalignment exists in all human communication, but for the most part it doesn't matter. It's only when we start applying rigor and making these systems larger that it becomes obvious they don't work anymore.\n\nGroucho Marx said \"I wouldn't join any club that would have me as a member\" Nietzsche's point was that by trying to describe our religion in uber rational terms as if it were a mathematical language, we were destroying the very thing we were trying to create. We're doing just the opposite of what we wanted. We have killed our god by trying to make him work as just another series of symbols for us to manipulate.\n\nDoes this mean that there is no God? Beats me. Let's say that you forced me to answer whether there was a god or not. If forced, I would argue that our experiences so far actually proves that there is a god, as long as you believe there will always be something to learn, a premise I believe to be true. Note that I'm not talking about a \"God of the Gaps\", some entity that represents places where we don't understand things. There is a second, more unknowable group of things, where we don't even have the language or symbols to represent it in any fashion. That's not The Unknown, the thing that's waiting for science to address. That's the Great Unknown, the thing we don't know that we don't know. In my mind, and remember you forced me, God is our civilization's zero. That's pretty cool.\n\nThe purpose of this essay isn't to say that we don't know anything, that all of science and knowledge is bunk. Just the opposite. We know a lot! This is an essay about creating and using tools to learn things. Looking at the Ladder of Civilization, when we're in each node, there's an emptiness, a void, in the nodes adjacent, so we create various tools to understand them. But whatever tools we create, they also contain these troublesome gaps that we can never eliminate. This essay is to tell us that we need to get really good at creating various systems of tools to explore reality, gaining more and more capability as we do so. At the same time, however, we have to keep in mind that there are no perfect tools. We can't put all of our belief in any one of these systems to move between nodes. It's completely natural that we expect society and the universe to behave in the same abstract ways our brains work. It's highly doubtful that this is the case. If we understand why and how we create and use tools, we'll be able to create and use better tools.\n\nIn deep and profound ways, we are like Newton. We have absolutely no idea what's going on, but we can describe it in math. The sad fact is that none of these nodes are directly accessible from another. We get from one to the other only indirectly, groping in the dark. We don't know stuff, and that's fine. There should be gaps. There will always be gaps. Just don't bite into the apple! That's what got us into all of this trouble!\n\n\n\n\n\n\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Daniel B. Markham](DanielsSignature)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\nI wrote this\n</figcaption>\n</figure>\n\n<div>\n<div class=\"embed-responsive embed-responsive-16by9\">\n<iframe class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/Plt3qLSeDHU?rel=0\" allowfullscreen></iframe>\n</div>\n<p class=\"figure-caption text-center text-muted\">\nEssay round-up\n</p>\n</div>","Excerpt":"In which babies are used to explain the universe","Approved":true,"Categories":["recQbvNMbYGcFSc8z"],"Tags":["rec8Q7Sn8p6DNLNKJ","recfhydFF7ur53pTS","recSfRhJdArFwzoIa","rec5R2SfJiDv86Th5"],"StartDate":"2019-10-15T09:00:00.000Z","Blog":["recCGKQBlTWHqrGCu"],"Questions":["recP7QjaaAmQLGdzy","reck1CpVvULaFWVba","recMMoTy278CTdyBI"],"TemplateFile":"Entry3.html"},"createdTime":"2019-10-15T13:35:03.000Z"},{"id":"recfZ2temlXHiiAfP","fields":{"ID":54,"Authors":["recPwgCd6QGPvd5Fg"],"Title":"Technology Ethics 2: Discriminator Functions","Content":"A friend messaged me the other day. Usually he's a big fan of my writing, but on this day he was trying to wave me off like an F-15 on a bad approach to an aircraft carrier. My idea that programmers need to talk more about ethics is troublesome. He was concerned that many programming forums can't distinguish between pointless bickering and ethics. It's just too tough. Bits are bits. Stick to bits! Bits don't argue.\n\n\"I'd like to think that objects have no morals,\" he said.\n\n\"Would you write code to shoot a tank if you were a pacifist?\"\n\n\"Dammit\"\n\n\"Yeah\"\n\nI'm not saying you should be a pacifist. I'm saying that if your morals are pacifism and you are asked to write code to shoot a tank, in addition to your moral dilemma of coding something that will kill people, now you have an ethical problem too: how do you professionally respond to customers who ask you to create code that you think has immediate immoral effects, regardless of whatever morals you have?\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![DVD cover to the movie Hacksaw Ridge](2019-09-MovieHacksawRidge)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    \n</figcaption>\n</figure>\n\n\nWe see this conflict play out in the movie version of Desmond Doss' life, \"Hacksaw Ridge\". Movies always dumb things down, so you might have missed the subtlety. The movie follows real-life Desmond Doss, who believes that any killing of another human is bad, as he gets drafted to fight in WWII.\n\nThe movie plays it out to be Doss and his morals against the system. This makes for more drama. But the interesting part of the story is that Doss decided that while killing other humans was bad, as a citizen who loved his country, and as a member of his religion, he had an ethical obligation to serve in the war. Because of his ethics, he joined and did everything required of him, save one thing: carry a gun. He felt that carrying a gun would lead to killing, and he refused to take that one action, deducing that this was the minimum action necessary to maintain his ethical obligations both to his fellow citizens and, more importantly, other religious people who believed the same way.\n\nEthics are not about right and wrong. They're about collective standards we hold ourselves to in order that other people will respect us. By Doss making the decisions he did, the rest of the people that felt that killing others was bad were treated better by the majority. We could all behave in a civil manner because this wasn't a force of wills where one person had to win and others had to lose. Ethics allowed both sides to claim the moral high ground and life to go on. In the movie \"Remains of the Day\", a butler feels an ethical obligation to do his job even under great hardship. We all know ethics; it's all around us. We just don't recognize them when we see them.\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Early artist's picture of the Boston Massacre](2019-09-BostonMassacre)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    \n</figcaption>\n</figure>\n\nIn the early days of the colonies, some British troops were accused of massacring colonists in Boston. It was tense. A young lawyer stepped forward willing to defend the soldiers. That lawyer was future president John Adams. People on both sides felt quite strongly and morally outraged that such a crime occurred. Each side knew that they were right. Adams felt that as a lawyer he had an ethical obligation to give the defendant the best effort he could. It was not about whether they were guilty or not. It was about whether the public knew what to expect when they employed lawyers. Would lawyers secretly decide who they liked or not, sending some to jail without a hope? If so, the public would lose trust in all lawyers. Civilization would suffer. Ethics holds our lives together.\n\nIn 1964 the U.S. presidential race was fraught with controversy. The Republican Party nominee, Barry Goldwater, was quite a character. At the time, the other party in the U.S. ran most of the states and controlled both houses of congress. They looked to maintain power for a long time to come. In addition, the Republicans looked like they had a difficult time finding somebody to run. After all, LBJ had just taken over after the awful death of JFK and nobody wanted to run against the ghost of JFK. It was impossible.\n\nSo they came up with Goldwater. He was, as they said in the day, \"out there\". He was not irrational, but he held views far to the right of most folks. Instead of softening his views for the general election like most politicians would do, he dug in. \"I would remind you that extremism in the defense of liberty is no vice. And let me remind you also that moderation in the pursuit of justice is no virtue.\"\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![The cover of fact magazine in 1966](2019-09-GoldwaterFactMagazine)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    Science!\n</figcaption>\n</figure>\n\nIn this climate, \"fact:\" magazine stepped in. They did a survey of hundreds of psychiatrists nationwide. Is Goldwater fit to be president or not? The answer was a resounding \"No!\" All the psychiatrists agreed. Goldwater was crazy. Or so the average reader probably thought from reading the cover. \n\nWhat happened? First, Goldwater lost as most everybody thought he would. Second, the job of psychiatrist took a heavy hit. If 40% or more of Americans don't think Goldwater is crazy but all the psychiatrists do, who are the crazy ones, the people that agreed with Goldwater or the doctors? More to the point, if they can read a few articles and tell whether you are crazy or not, why go get mental health? What good can it do?\n\nAs far as everybody can tell, the story didn't impact the election, but it sure turned a lot of people off to the idea of working on their mental health. It most likely prevented tens of thousands of people from seeking out psychiatrists that needed them. It was a disaster for people who really needed help, and it terribly harmed the profession, leading to the \"Goldwater Rule\", which basically said shut up when the reporters come knocking asking about the mental health of a famous person. You're hurting our profession. You're hurting the people we're trying to help.\n\nControversies and crises pass. Maintaining ethics helps people people in this profession 100 years from now do a good job.\n\nEverybody knows the Space Shuttle disaster story: engineers knew that very bad things might happened if they continued to launch in cold weather but were ignored. More recently, in Boeing's 737MAX series of disasters, it _may_ be that there were engineers or groups that knew that using only one AoA sensor could lead to disaster.\n\nWe naturally focus on the big story, the war, the massacre, the explosion, the crashes. But ethics is about the small story, how each of us act under stress. Given these observations in our profession, what are the types of reactions that we feel as a group do the best to maintain public trust? (And by extension trust in one another)\n\nA common question I get when I coach teams is this: we are being put in an impossible situation! (Long story goes here which usually ends up being some version of management over-constraining the team so that they cannot succeed and higher-ups all lying and using happy-talk to one another to prevent any positive change from happening) Things suck. What's the right thing to do now, Mr. Smart Guy?\n\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![This is Sparta!](2019-09-ThisIsSparta)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    This is Sparta! The Spartans didn't mess around with parsing words and doing a lot of thinking. This isn't like being a Spartan.\n</figcaption>\n</figure>\n\nWhile there might not be a right thing to do, I believe there's an ethical thing to do. You may not be able to solve all of the problems of your organization, but I strongly feel that you have an ethical obligation to communicate the problems you uniquely see in the best way possible so that these problems can't be ignored and instead positive movement can happen.\n\nIf, on the other hand, you get stuck in concepts of right and wrong, this person is acting right and that person is acting wrong, is this value more or less important than this other one, then suddenly you're not helping the organization solve this problem, you're off on some personal mission make the world a better place. That may be a wonderful personal mission, but meanwhile there are a lot of people and families that depend on the organization working correctly (or as best as it can). \n\nI'll be more direct again: who wants to hire programmers if they're going to turn everything into a moral conflict and crusade amongst themselves? I don't know about you, but I'd want to hire professionals, people who realize that others in the org may be doing the wrong thing, but they also might not be. We assume positive intent. We ask people to explain things. We try to act in an ethical manner so that we can all work together. Personal morals may tell each of us what's right or wrong, but ethics holds us together.\n\nI could go down a list of things I find troublesome in the world: fully-autonomous weapons systems, the surveillance state, the way people interpret open space, the terrible way we treat some offshore programmers, how we bill our customers, how we treat our contractors, and so forth. I'm sure everybody has their list. These things are important to each of us, but *collectively* it is **meta important** that we talk about how we as programmers should act when we find ourselves in one of these situations that works against our values, no matter what our values are. \n\n## Now you know ##\n\nNow that you and I have kicked around this idea of ethics a little bit, we can see that my friend was right; a lot of people just aren't wired up for this concept of acting or talking about ethics. They want heroes versus villains, high drama. It's all morality all the way, from top to bottom. Choose up your sides, bastards! Have at you! But, sadly for all of us, I am also right; we no longer have the luxury of just lumping everything difficult into a big bucket and ignoring it. For programmers, ethics are here to stay. There are tens of thousands of programmers right now going through ethical dilemmas and nobody has done anything to prepare them for it. There's not even a place to talk about it.\n\nIf we agree on ethics, then we can all work together in places where we disagree on a lot of other things. In this fashion we create a trust and respect for our jobs. Otherwise it's just going to get worse. Each new news story involving software is going to create anger and a backlash in the public mind. Eventually the choices we might have now are going to be taken away by law.\n\n<div>\n<div class=\"embed-responsive embed-responsive-16by9\">\n<iframe class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/SEUGvzUPwn0?rel=0\" allowfullscreen></iframe>\n</div>\n<p class=\"figure-caption text-center text-muted\">\nLet's talk about how to sort ethical conversations out from everything else\n</p>\n</div>\n\n## Definitions ##\n\n**Ethics** -- the agreed-upon practices that a group of professionals adopt regardless of what any one of them might think is right or wrong or what any of their politics are. It is a pattern of behavior that they promise to perform when they make certain observations about their job. By knowing to expect this pattern of behavior, the public can trust the profession more. In addition this allows for members of the profession to have wildly different personal values and work together.\n\nThis leads to several conclusions:\n\n- While ethics can and should be recommended and adopted by professional bodies, at the end of things they're always personal. There's always interpretation and leeway, and it is always up to the individual to make the tough decisions given the guidelines they're provided\n\n- Ethics exist and are useful where there's conflict. You or most people you know feel strongly a certain way but its in the general overall longterm interests of your group that you not act directly on those feelings. That should be a painful feeling. If it's not painful, it's not useful as an ethical discussion\n\n- The natural enemy to any ethical standard is the old refrain \"But this time it's different\" especially when our ethics are tested *en extremis* This time the guy is really guilty. This time the war is a war to the death. Ethics is tough because if we look hard enough, in some way it's always different\n\n- Ethics are not documents, they're social agreements. They get definition through conversations, sometimes arguments, among practitioners who have more and different experiences than you do. You can't separate ethics from a social group or tradition, nor would you ever want to\n\n- Since ethics are associated with groups, since they're personal, and since the purpose is to establish trust with and between the group, ethical failures should naturally result in being removed from the group. That's not a hard and fast rule; it just all follows from our givens. If this weren't true, otherwise each of us when coming across a difficult situation would just make the case that it's different now, ignore the ethical rule, and go about our ways without consequences. That's effectively no ethics at all\n\n- When we discuss ethics in groups, it can't be about any specific person, event, or political party or conflict. This isn't a current events bull session. It *may* be fine to bring these up as an example to talk about ethics, but only if people can put their passions aside and talk to the issue from all angles. For most current events in larger groups the answer to this is \"no\". Large groups always have single-issue people who are quite upset about one aspect of whatever the current event is. Good ethics should support these folks, but in the heat of the moment, they tend not to be able to look at the other issues involved and see the views that other single-issue folks might have. It becomes drama. Some Internet forums have used time limits as a possible fix for this\n\n- Because of that, smaller groups may be better positioned to initially discuss tough ethical issues based on current events, where widely-divergent opinions can reach some kind of consensus that can then be presented or explored as a larger group. The smaller group can never decide or dictate, but may be much better at reaching an initial resolution and being able to explain it when given difficult problems. Those explanations can then be discussed by the larger group\n\n- We can't design the perfect system. Ethics fail us at times. Those failures, addressed honestly, make for good conversations about how to improve\n\n## Format ##\n\nHere's a format I've been playing around with.\n\n**BECAUSE:** *A belief(s) about the people we're trying to help. Our premise*\n\n\n**WHENEVER:** *Observation(s) around things we see and things we're doing*\n\n\n**IT HAS TO BE THAT:** *Behaviors indicated by our ethical guideline*\n\n\n**SO THAT:** *Reason for the guideline and the result we would expect over time*\n\n\nWith a standard template for ethics, various groups can begin to create discriminator functions to figure out what works or doesn't for each group. Now that we've established a baseline through the use of examples, the next step is creating a discriminator for a particular case. To have a good discriminator we have to have a good data structure.\n\nI believe this format allows us not only to create ethical rules, but to evaluate why they were created and whether they're actually doing what they're supposed to be doing. We also shouldn't be creating a ton of ethical guidelines. Less is more. Just guessing, maybe a dozen for a professional association and another dozen for a small team working agreement, but I'm pulling those numbers out of my ass. I know if I can't remember them, they're not working.\n\n## QA Checklist (beta) ##\n\n[ ] Timeless. Would theoretically work 100 years ago or 100 years from now\n\n[ ] Represents the simplest rule that would work \n\n[ ] Understandable by everyone \n\n[ ] Establishing trust is the goal\n\n[ ] Generalized. Not in any way related to any person, event, movement, cause, or belief (not associated with the group, of course)\n\n[ ] Universal. This is something you would be happy if everybody in your group implemented\n\n[ ] I have direct control over the results through my actions \n\n[ ] Social. Does not exist outside a tight social context\n\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Daniel B. Markham](DanielsSignature)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\nI wrote this\n</figcaption>\n</figure>\n\n","Excerpt":"Double sigh","Approved":true,"Categories":["recQbvNMbYGcFSc8z"],"Tags":["rec8Q7Sn8p6DNLNKJ","receRQaf4IK9F57ip","recKf7tKStW0JK4cf","recSfRhJdArFwzoIa"],"StartDate":"2019-09-26T14:00:00.000Z","Blog":["recCGKQBlTWHqrGCu"],"Questions":["recbHiSxqyBiNiuDv","recMMoTy278CTdyBI"],"TemplateFile":"Entry3.html"},"createdTime":"2019-09-26T17:46:49.000Z"},{"id":"recJgpI5Fi77utG7Z","fields":{"ID":53,"Authors":["recPwgCd6QGPvd5Fg"],"Title":"It's time programmers talked about ethics","Content":"\n<div>\n<div class=\"embed-responsive embed-responsive-16by9\">\n<iframe class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/c7vhCpZsgSk?rel=0\" allowfullscreen></iframe>\n</div>\n<p class=\"figure-caption text-center text-muted\">\nA preview\n</p>\n</div>\n\n## Please, no more political posts!\n\n\"I don't want to talk about politics\" should be a t-shirt or hat given to every new programmer their first day on the job. It is one of the most common refrains you hear in programming Internet forums and it's been the policy of many a successful Internet technical site.\n\nIt's both right and wrong. I think the sentiment is exactly right but the words are bit too undefined and the concept misused.\n\nI get it. You're online trying to figure out how to implement a bubble sort in QBASIC for that pet Donkey Kong project you've always wanted to code, and here's some dude bringing up the Venezuelan Beaver Cheese Crisis. They're upset about it, they've already decided about what needs to be done, and the only thing that's going to happen is that a lot of really smart and talented coders are going to waste time arguing about (perhaps) critically-important stuff that nobody is going to agree about and nobody will change their mind. Worst-case everybody hates one another at the end. Best-case it's a form of intellectual masturbation. Instead of working doing useful coding stuff, everybody spends their morning passionately instructing some other person desperate not to work on why they're wrong on the Internet. No thanks.\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![A screenshot from the old Donkey Kong arcade game](2019-09-ClassicDonkeyKongGame)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    \n</figcaption>\n</figure>\n\nDon't get me wrong, it may be a world-changing important, emotional, and immediate debate that has to happen, it just doesn't have to happen here, not with that Donkey Kong thing you've got going on. Shut the hell up about politics and just talk code, please!\n\nI get it.\n\nSo we talented, focused, and hard-working coders have been doing this for years, decades even, and what we've found is all of those little technical bubble-sort-like questions were answered, products were built, and suddenly we're living in a world now where there are all of these software products are doing things nobody really wants. Not all of them, of course, but a lot. Sure, we coders knew what we were building as we were building them, but that's politics, right? Coders were working in projects building components that didn't work right and ended up killing people, but how were they supposed to bring it up to their boss's boss? That's politics, right? The IPO they're in is a snake oil show, and most of the coders know it, but that's politics, right? They're thinking about selling rights to our code to an oppressive regime that plans to use it to control people, but that's politics, right? Just give me the code.\n\nWe all kept politics out as much as we could. We got online and boiled everything down to bits and bytes, ignoring in our forums where code is ending up and how people have been hurt. All this time we were really building weapons, truth be told, weapons more powerful than the A-bomb, but we were doing it in tiny little distributed pieces so each of us could pretend that the use of the weapon and the piece we made are completely unrelated. We kept it productive. We only cared about GC in Java and the fact that some guy in Bavaria used that code to build a giant robot that shot up those surfers? We couldn't have known that, could we? But this is a circular argument. We refuse to talk about the larger effect of things then claim that we couldn't have known how the things we've built could have been put to a larger use. We could have never known that anything we do at all could ever be bad because we refuse to talk about anything controversial at all under the rubric that all controversial things must be a waste of time. They're politics. Ask me how to build an AI-powered death ray that only kills clowns and that's a technical question. Post a story about how death squads are using AI-powered death rays to kill clowns and that's politics.  We win every time. We live in a consequences-free world. Everything is just bits and bytes without any of it ever amounting to something controversial. Ever. Isn't it nice here?\n\nThat's where we got it wrong.\n\nPolitics is the public process of people seeking to right wrongs in the world. If we're solving problems, we don't need to talk about politics. That is, we don't need to talk about anything that is in the current news: political figures, political decisions, political parties, political movements. If it's trending on Facebook or Twitter? Good money says it's a emotive knee-jerk clickfest and we have work to do. Maybe a better way of putting it is \"We don't want to talk about current people and events doing controversial things\" We fix defined problems right here, in the IDE in front of us. Most of politics is people not agreeing there is a problem, what the problem is, or how to solve it. All of that doesn't fit with our jobs. \n\nPerhaps a good rule would be that if it happened five, ten, or fifteen years ago and people can talk about it without going crazy? If it's tech-related we can probably talk about it. Let's try, see how it works.\n\nAt least then we might save everybody's time and keep discussions useful, but we still need to stay laser-focused on useful career information we can share, not who did the CGI for Batman ten years ago. There has to be a place to talk about the profession of programming. That place is right alongside where we talk the details of programming. My fellow dudes, we gotta talk ethics. In various ways, many of us are participating in the building of things that hurt people. Without talking about particular people, products, news stories, or current events, we **must** talk about how we think professional programmers should conduct themselves in an environment where code isn't just Donkey Kong anymore. \n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Terminator Skull](2019-09-TerminatorSkull)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    \n</figcaption>\n</figure>\n\nWe can't go on like this, ignoring it. It's reached the point where tech, the tech many of us built in some way, is being used to do terribly dramatic and controversial things. We end trying to force one another to talk about it anyway. We post these stories. \"What the hell?\" the poster asks. \"Some programmer built this?\", \"Should I help do X\", \"Building sort doesn't hurt people, so where's the line?\", \"How is it okay to track this information?\", or \"Should I take a job with people doing stuff I think is immoral? How about letting them use my code?\"\n\nThere are really good questions that we need to ask as a programming profession that only we can ask. Trust me, we have reached the point where it's either we talk about it or others will talk about it and make decisions for us. Nobody wants that. This isn't going away. So let's figure out how to talk about being a professional and respectable programmer who can sleep easily at night and whom other people trust and confide in. We can do that without endless arguments if we set some ground rules and just talk generics.\n\n## Ground Rules\n\n- No current controversies. Pick a time limit, anything within that time limit is off-limits. People are just too wound up about it, and we're not looking to argue, we're looking to make ourselves better. That's why we meet.\n- Separate the personal from the professional from the public. We have to acknowledge different levels of what's okay or not or we won't be able to discuss anything, dynamic types or killer robots, doesn't matter. It's okay to feel strongly that something is wrong and still think it's the right thing to do to let other people do it. That doesn't make you a hypocrite, it makes you a human. There are a lot of wrong people in the world.\n    + **Morals** - my relationship with myself and my higher power. Morals are the things I hold most deeply, the things I'm willing to get upset about and tell you why right is right and wrong is wrong, dammit. Nobody else in the universe has the personal morals I do. I create them with the decisions I make.\n    + **Ethics** - how I feel all of us should act as a profession so that we know what to expect from one another and that people will hold us in high regard. Ethics is what we really need to talk about. Not what's right or wrong, but what standards we should strive to uphold so that each of us can be passionate about our morals while still acting in a way that's predictable and honorable to outsiders.\n    + **Laws and Regulations** - those things that I feel that I should have no control over. I never want to build a quadcopter that looks like a spider, I think it's immoral, I think it's unethical. It's so bad that nobody should do it ever. Anybody who builds one should be caught and punished. This is what we're going to get, and we're going to get it good and hard, if we don't come up with a good set of professional ethics. (And we're not going to be the ones creating them.) Of course, government can be good! There's a needed role for laws and regulations, but it should be as a last resort, only when an industry has shown an inability to control itself. But come on! We're programmers. We've got this.\n- Always assume positive intent\n- Seek agreement on the general, historical then move to the specific and recent\n- Always be looking for the simplest question everybody can agree on where well-meaning and intelligent people have different answers. That's where you learn stuff \n\n## Levels of Ethical Concern in Human-Machine Interaction\n\nI'm not going to leave you without something useful, so here's a first stab at levels of ethical concern for writing code that interacts with people. I'm not telling you what to do or not. All I did was make an ordered list of how concerned I would be from an ethics standpoint in building various pieces of code based on how it interacts with people. For each level maybe I'd get a yes or no answer. I might build it or I might refuse on ethical grounds, but stuff in level one is a much easier \"yes\" than stuff in level ten, which I find mostly evil. As the levels go up I'd have to think long and hard about agreeing to write the code.\n\n- Collecting truly anonymous data somebody needs for something they're paying for.\nSEDE Stream Encrypted Data Exchange, PKI-like system for individual data recordings\n    + Must have producer anonymous to all other systems aside from one\n    + Must have consumer anonymous to all other systems aside from one\n    + Must exist for a financial reason obvious to both\n    + Can only contain one column of a relevant financial transaction\n    + Is aggregated in a random and nonstandard time chunks by consumer\n    + Can only exist for a certain time based on the type of transaction \n- Reporting a sensor reading \n- Doing a trivial, yet perhaps time-consuming thing for a human\n- Answering a non-current-events question\n- Advising a human what to do with a detailed explanation\n- Telling/nudging a human on what to do (or advising without an explanation)\n- Making a decision for a human that reasonable people might debate\n- Passively preventing humans from doing something\n- Actively causing humans pain or harm\n- Carte blanche telemetry. Lab-rat tracking.\n- Lying to humans \n\nPlease throw this away or break this down any way you'd like. There's another list involving programmer/project manager/code licenses that needs to be made. What are the types of agreements I have with others about making code for them? Just like here, there are criteria to be outlined, a level of difficulty involved in making decisions, and discussions that need to be had.\n\nNo matter how we want to do it, there's a ton of work around how we can be better, more ethical professionals. We need to do it, at least as much as that Donkey Kong thing you were working on. Plus, I don't think we have a choice. We either start being very active about what makes a professional, ethical programmer or not or others will decide it for us. Pick one. I'd rather us do it.\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Daniel B. Markham](DanielsSignature)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\nI wrote this\n</figcaption>\n</figure>\n\n\n<br/><br/><br/><br/><br/><br/><br/>","Excerpt":"Sigh.","Approved":true,"Categories":["recQbvNMbYGcFSc8z"],"Tags":["rec8Q7Sn8p6DNLNKJ","receRQaf4IK9F57ip","recKf7tKStW0JK4cf","recSfRhJdArFwzoIa"],"StartDate":"2019-09-22T05:00:00.000Z","Blog":["recCGKQBlTWHqrGCu"],"Questions":["recbHiSxqyBiNiuDv","recMMoTy278CTdyBI"],"TemplateFile":"Entry3.html"},"createdTime":"2019-09-22T09:19:14.000Z"},{"id":"recSYQ1wis5dofZC9","fields":{"ID":52,"Authors":["recPwgCd6QGPvd5Fg"],"Title":"Learning at Scale: Definitions","Content":"\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Cat in a tesseract house](2019-09-LearningAtScale5)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    Where is this?\n</figcaption>\n</figure>\n\nI am writing a book about critical path learning at scale. That includes startups, program/product management, org change, the sciences, and artificial intelligence. Wow! That should be easy enough, right? To get started, here are some definitions. Yes, we could spend the next ten years or more arguing each of these, but if they work for us right now, they're good. When they stop working, we'll get new ones. Let's let somebody else finish it. We've got work to do.\n\n### Education\n\nWhat is education? Education is the continuous acquisition of habits (habitual behaviors) which show us that we're wrong about some area (our area of education) and our ability to adapt and change based on that new knowledge. It's a collection of habits that allow us to find out where we're wrong in a certain area so we can be better there.\n\n### Consciousness\n\nWhat is consciousness? The sensing and incorporation of new experiences (sensory input) into a different view of the world. Consciousness is not boolean. It can be done at various levels. Plants sense where the sun is as it moves and change their nature. This is probably the most primitive form of consciousness. Consciousness is something you do, not something you are.\n\n### Intelligence\n\nIntelligence is the ability to predict, adapt, and change our behavior based on the construction and manipulation of ideas in the abstract. Education depends on intelligence. If we cannot grasp and reason about things in the abstract, we cannot be educated about those things. Remember the old insult: a person has been \"educated beyond their natural intelligence\" It is neither an untrue observation at times or an uncommon condition to see.\n\n### Language\n\nLanguage is the ability to take our individual abstractions and compare them as a group of people. In humans, languages are primarily socially-contextual gestures, with sound-making as a secondary effect. Over time, the sound-making becomes ritualized into what most call a spoken language. For a very few spoken languages, a permanent symbolic system of recording is created called a written language.\n\nLanguage is a conscious dance of behaviors where our education guides our intelligence to receive some series of transactional values.\n\n### Intuition\n\nIntuition is the ability to make correct guesses about the current and future state of things based on very limited, contradictory, or no information (sensory input). Psychics, if they existed, would be the most intuitive people. Since sensory input is always imperfect, we are all intuitive to various degrees. We have to be. The inconsistency of sensory input for each of us? It drives a sort of bubbling creative chaotic destruction and creation everywhere else throughout our model. Thankfully.\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Things and stuff](2019-09-LearningAtScale1)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    \n</figcaption>\n</figure>\n\n### What types of things are we talking about here?\n\n**Sensory Input** gives us the qualities of objects, not the objects themselves. An apple looks one way from one angle, another way from another. Toss the apple and it looks yet another way. The same sensory input can represent multiple objects, and any object can have multiple sensory inputs. Sensory inputs can change seemingly at random.\n\n**Meaning graphs** are a probabilistic connect for which some objects are guessed to be associated with others to varying degrees.\n\nWhich brings us to **objects**, which for this discussion will be a series of behaviors and meaning graphs consisting of at least one. Moving a finger is an object. Petting a cat is an object. \" Run outside if you see a fire\" is one. Objects can exist at all kinds of levels of recursion and complexity. I will use objects and object chains interchangeably, depending on whether I wish to focus on the idea that it is a single thing or whether I want to focus on the fact that this single thing actually can represent quite a complicated chain of graphs.\n\nThere are **qualities**, which are the attributes objects have. There is a natural and necessary tension between objects and their qualities.\n\nThere are **supplementals**, which for our purposes are things that always must be true about objects. An object which is of a chain of this type must always have this other object as the next node. These nodes must always look this way. Supplementals are never always true, otherwise there would be no need for consciousness, education, or learning, but *supplementals always must be treated as if they were always true*. **Supplemental chains** are behaviors that generate sensory input such that we can create many possible object chains. In OODA terms this would be the Observe and Orient phases.\n\n**Learning** is creating and changing new supplemental chains such that we don't have to continue to work on them. Our supplemental chains are firmly in place. We have learned something. It's the Bayesian/Frequentist process of constructing various objects (which have various qualities) and finding which supplementals work for them ... or at least work well enough that we never have to guess about what the supplementals might be in the future. For any non-trivial learning, this is usually done alongside various sensory inputs to be on the lookout for which might indicate a deviant case where the learning does not apply. \"If you're hammering a nail, and a crack in the wood appears, the hammering-nail chain is probably no longer appropriate\" This would pop us from learned-behavior mode back into learning mode. Most adult humans spend most of their lives in learned-behavior mode. Time flies, right?\n\n![Lives](2019-09-LearningAtScale2)\n\n**Subjective Life** is the only thing living beings inhabit, as it represents their own internal mental lives. There are subjective qualities, subjective objects, and subjective supplementals. It does not stay fixed. Instead life always changes. Biology rules that useful organisms are able to change along with it to their advantage.\n\n**Abstract Life** is an ever-changing life that sentient beings own where various groups of subjective things are grouped into abstract things which represent them. Abstractions can be done in various ways and for various reasons. The definition of intelligence is the ability to quickly create and use the most advantageous abstract supplemental chains given various situations. There are no fixed abstractions, although many believe there are. Instead there are longer and shorter-lived abstractions depending on whatever is useful at the moment. All swans are white, at least until you meet a black one.\n\n**Conversational Life** is the use of language among a group of sentient creatures to arrive at seemingly shared abstractions. There is no fixed set of shared abstractions, although many believe there are. Instead there are just longer or shorter-lived language concepts depending on whatever is useful at the moment.\n\nAs humans created spoken languages, then written languages, then began discussing their internal abstract lives more and more in communities, the idea of a universal or **Real Life** took hold. (It was a very long process, even after the Greeks). We guess that there is a real life, and that it may be similar to the others. Sure looks that way.\n\n![Fun activities for the entire family](2019-09-LearningAtScale3)\n\nThis creates a system of twelve nodes, three nodes per layer; qualities, objects, and supplementals, and four layers; subjective, abstract, conversational, and real. **Each of these nodes is directly inaccessible from the others.** Instead we must get at them through various \"tricks\" or techniques. We perceive them indirectly, make guesses about what they are, and proceed as if our guesses are accurate.\n\nThis is the way reality is wired, not something any of us naturally knows or thinks about. Why would we? For the dog who sees the man throw the stick, fetches it, and gets petted, there are those sensations of the man, the stick, and the throwing, the behaviors of getting the stick and bringing it back, and the reward. This is just existence. For the ancient philosophers, who suddenly lived in a world which had printed symbols to represent \"things most people agreed on well enough to get along with one another\", they thought that perhaps the symbol *was* the thing, or perhaps there was a *perfect version* of the thing. \n\nThere was much confusion.\n\nThese are all reasonable assumptions. Until we started teasing out layers, and until we thought about the difference between perceptions among people, and until various forms of physics had been tried and failed...I could go on. Each of these nodes and the relations between them have a long history. Much is still being debated today. To the plant that sees the sun move and changes to get more sunlight, that's all there is. To the large human population existing in various small social groups trying to create a rigorous system that explains everything, suddenly things get complicated, perhaps impossibly so.\n\nMy belief is that we would have continued flailing around at this problem without resolution had it not been for programming. It's the programmer who is the person who has to take several people with their own subjective lives, along with their current working versions of various abstractions, use language to negotiate amongst them conversationally with a goal of creating a self-consistent grouping of mathematical symbols representing state and behavior changes such that we can reproducibly explore the outside universe using a rigorously agreed-upon and consistent framework. We program solutions for folks.\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![The nodes](2019-09-LearningAtScale4)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    \n</figcaption>\n</figure>\n\nTurns out that this type of exploration is called science. All the things that go into setting up that exploration is called philosophy. This is why philosophy is the mother of the sciences. It's not that philosophy came before science, it's that the proper use of philosophy creates a new science. But historically all of this is really slow, it's traditionally involved generations of really smart people. True species-level learning, learning-about-learning, might never have occurred had we stuck to this pace. Programming, however, crams generations of smart people asking interesting questions to drive out a science into a six-week web application. (Although, admittedly, the \"science\" involved might be the exploration of what kinds of fart sounds the average teenager likes and why). You do this over and over again, tens of thousands of times a year, and slowly the nodes start to appear. They're not living invisibly in the background anymore. Repeated application development in various social contexts has driven them out.\n\nIn the end we're all just left with behaviors and sensory qualities, making up the rest as best we can. If you didn't get all of this, no worries. Nobody else throughout history did either. It's that \"making up the rest as best we can\" part where things get really interesting; it's what this book is about.\n\n<a href=\"https://leanpub.com/info-ops3?ref=blog\">Stay tuned here for more information on the upcoming book and to qualify as a beta reader.</a>\n\n<div>\n<div class=\"embed-responsive embed-responsive-16by9\">\n<iframe class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/hmWBPhPfHMc?rel=0\" allowfullscreen></iframe>\n</div>\n<p class=\"figure-caption text-center text-muted\">\nA preview\n</p>\n</div>\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Daniel B. Markham](DanielsSignature)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\nI wrote this\n</figcaption>\n</figure>\n","Excerpt":"It's possible to talk about learning and intelligence in the abstract and at scale, but how would that look?","Approved":true,"Categories":["recQbvNMbYGcFSc8z","recZLPmdZt7GBUMCG","recnSIAaEwa0CbWuE"],"Tags":["rec8Q7Sn8p6DNLNKJ","recfhydFF7ur53pTS","recLfkSmV5wJby8YI","recSfRhJdArFwzoIa","recjO5SXNjUCNgBS9","rec5R2SfJiDv86Th5","recmQrVciifkRQ7Ue"],"StartDate":"2019-09-08T08:00:00.000Z","Blog":["recCGKQBlTWHqrGCu"],"Questions":["recP7QjaaAmQLGdzy","reck1CpVvULaFWVba","reckKRruy3mvt092D"],"TemplateFile":"Entry3.html"},"createdTime":"2019-09-08T11:58:09.000Z"},{"id":"rece2L2D3B2ZeyHTe","fields":{"ID":51,"Authors":["recPwgCd6QGPvd5Fg"],"Title":"Proposal: Code Cognitive Load","Content":"\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Error message](2019-09-LearningAtScale5)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    This is an actual error I ran into using an expensive commercial application a few days ago.\n</figcaption>\n</figure>\n\nI am writing a book about critical path learning at scale. That includes startups, program/product management, org change, the sciences, and artificial intelligence. Wow! That should be easy enough, right? To get started, here are some definitions. Yes, we could spend the next ten years or more arguing each of these, but if they work for us right now, they're good. When they stop working, we'll get new ones. Let's let somebody else finish it. We've got work to do.\n\n### Education\n\nWhat is education? Education is the continuous acquisition of habits (habitual behaviors) which show us that we're wrong about some area (our area of education) and our ability to adapt and change based on that new knowledge. It's a collection of habits that allow us to find out where we're wrong in a certain area so we can be better there.\n\n### Consciousness\n\nWhat is consciousness? The sensing and incorporation of new experiences (sensory input) into a different view of the world. Consciousness is not boolean. It can be done at various levels. Plants sense where the sun is as it moves and change their nature. This is probably the most primitive form of consciousness. Consciousness is something you do, not something you are.\n\n### Intelligence\n\nIntelligence is the ability to predict, adapt, and change our behavior based on the construction and manipulation of ideas in the abstract. Education depends on intelligence. If we cannot grasp and reason about things in the abstract, we cannot be educated about those things. Remember the old insult: a person has been \"educated beyond their natural intelligence\" It is neither an untrue observation at times or an uncommon condition to see.\n\n### Language\n\nLanguage is the ability to take our individual abstractions and compare them as a group of people. In humans, languages are primarily socially-contextual gestures, with sound-making as a secondary effect. Over time, the sound-making becomes ritualized into what most call a spoken language. For a very few spoken languages, a permanent symbolic system of recording is created called a written language.\n\nLanguage is a conscious dance of behaviors where our education guides our intelligence to receive some series of transactional values.\n\n### Intuition\n\nIntuition is the ability to make correct guesses about the current and future state of things based on very limited, contradictory, or no information (sensory input). Psychics, if they existed, would be the most intuitive people. Since sensory input is always imperfect, we are all intuitive to various degrees. We have to be. The inconsistency of sensory input for each of us? It drives a sort of bubbling creative chaotic destruction and creation everywhere else throughout our model. Thankfully.\n\n### What types of things are we talking about here?\n\n**Sensory Input** gives us the qualities of objects, not the objects themselves. An apple looks one way from one angle, another way from another. Toss the apple and it looks yet another way. The same sensory input can represent multiple objects, and any object can have multiple sensory inputs. Sensory inputs can change seemingly at random.\n\n**Meaning graphs** are a probabilistic connect for which some objects are guessed to be associated with others to varying degrees.\n\nWhich brings us to **objects**, which for this discussion will be a series of behaviors and meaning graphs consisting of at least one. Moving a finger is an object. Petting a cat is an object. \" Run outside if you see a fire\" is one. Objects can exist at all kinds of levels of recursion and complexity. I will use objects and object chains interchangeably, depending on whether I wish to focus on the idea that it is a single thing or whether I want to focus on the fact that this single thing actually can represent quite a complicated chain of graphs.\n\nThere are **qualities**, which are the attributes objects have. There is a natural and necessary tension between objects and their qualities.\n\nThere are **supplementals**, which for our purposes are things that always must be true about objects. An object which is of a chain of this type must always have this other object as the next node. These nodes must always look this way. Supplementals are never always true, otherwise there would be no need for consciousness, education, or learning, but *supplementals always must be treated as if they were always true*. **Supplemental chains** are behaviors that generate sensory input such that we can create many possible object chains. In OODA terms this would be the Observe and Orient phases.\n\n**Learning** is creating and changing new supplemental chains such that we don't have to continue to work on them. Our supplemental chains are firmly in place. We have learned something. It's the Bayesian/Frequentist process of constructing various objects (which have various qualities) and finding which supplementals work for them ... or at least work well enough that we never have to guess about what the supplementals might be in the future. For any non-trivial learning, this is usually done alongside various sensory inputs to be on the lookout for which might indicate a deviant case where the learning does not apply. \"If you're hammering a nail, and a crack in the wood appears, the hammering-nail chain is probably no longer appropriate\" This would pop us from learned-behavior mode back into learning mode. Most adult humans spend most of their lives in learned-behavior mode. Time flies, right?\n\n**Subjective Life** is the only thing living beings inhabit, as it represents their own internal mental lives. There are subjective qualities, subjective objects, and subjective supplementals. It does not stay fixed. Instead life always changes. Biology rules that useful organisms are able to change along with it to their advantage.\n\n**Abstract Life** is an ever-changing life that sentient beings own where various groups of subjective things are grouped into abstract things which represent them. Abstractions can be done in various ways and for various reasons. The definition of intelligence is the ability to quickly create and use the most advantageous abstract supplemental chains given various situations. There are no fixed abstractions, although many believe there are. Instead there are longer and shorter-lived abstractions depending on whatever is useful at the moment. All swans are white, at least until you meet a black one.\n\n**Conversational Life** is the use of language among a group of sentient creatures to arrive at seemingly shared abstractions. There is no fixed set of shared abstractions, although many believe there are. Instead there are just longer or shorter-lived language concepts depending on whatever is useful at the moment.\n\nAs humans created spoken languages, then written languages, then began discussing their insternal abstract lives more and more in communities, the idea of a universal or **Real Life** took hold. (It was a very long process, even after the Greeks). We guess that there is a real life, and that it may be similar to the others. Sure looks that way.\n\nThis creates a system of twelve nodes, three nodes per layer; qualities, objects, and supplementals, and four layers; subjective, abstract, conversational, and real. **Each of these nodes is directly inaccessible from the others.** Instead we must get at them through various \"tricks\" or techniques. We perceive them indirectly, make guesses about what they are, and proceed as if our guesses are accurate.\n\nThis is the way reality is wired, not something any of us naturally knows or thinks about. Why would we? For the dog who sees the man throw the stick, fetches it, and gets petted, there are those sensations of the man, the stick, and the throwing, the behaviors of getting the stick and bringing it back, and the reward. This is just existence. For the ancient philosophers, who suddenly lived in a world which had printed symbols to represent \"things most people agreed on well enough to get along with one another\", they thought that perhaps the symbol *was* the thing, or perhaps there was a *perfect version* of the thing. \n\nThere was much confusion.\n\nThese are all reasonable assumptions. Until we started teasing out layers, and until we thought about the difference between perceptions among people, and until various forms of physics had been tried and failed...I could go on. Each of these nodes and the relations between them have a long history. Much is still being debated today. To the plant that sees the sun move and changes to get more sunlight, that's all there is. To the large human population existing in various small social groups trying to create a rigorous system that explains everything, suddenly things get complicated, perhaps impossibly so.\n\nMy belief is that we would have continued flailing around at this problem without resolution had it not been for programming. It's the programmer who is the person who has to take several people with their own subjective lives, along with their current working versions of various abstractions, use language to negotiate amongst them conversationally with a goal of creating a self-consistent grouping of mathematical symbols representing state and behavior changes such that we can reproducibly explore the outside universe using a rigorously agreed-upon and consistent framework. We program solutions for folks.\n\nTurns out that this type of exploration is called science. All the things that go into setting up that exploration is called philosophy. This is why philosophy is the mother of the sciences. It's not that philosophy came before science, it's that the proper use of philosophy creates a new science. But historically all of this is really slow, it's traditionally involved generations of really smart people. True species-level learning, learning-about-learning, might never have occurred had we stuck to this pace. Programming, however, crams generations of smart people asking interesting questions to drive out a science into a six-week web application. (Although, admittedly, the \"science\" involved might be the exploration of what kinds of fart sounds the average teenager likes and why). You do this over and over again, tens of thousands of times a year, and slowly the nodes start to appear. They're not living invisibly in the background anymore. Repeated application development in various social contexts has driven them out.\n\nIn the end we're all just left with behaviors and sensory qualities, making up the rest as best we can. If you didn't get all of this, no worries. Nobody else throughout history did either. It's that \"making up the rest as best we can\" part where things get really interesting; it's what this book is about.\n","Excerpt":"We can make a metric that's more useful when talking about your application than anything else we could say","Approved":true,"Categories":["recD6fV22IR0LSVdB","recQbvNMbYGcFSc8z"],"Tags":["recSfRhJdArFwzoIa","recrv9vV7H2K5WayC","recLfkSmV5wJby8YI","recIPGRFebYI7QFwM"],"StartDate":"2019-08-26T07:00:00.000Z","Blog":["recCGKQBlTWHqrGCu"],"Questions":["recYUu7t6kgQ63oZx","recBzTpNr8bQsLN9x"],"TemplateFile":"Entry1.html"},"createdTime":"2019-08-26T12:43:08.000Z"},{"id":"recUeZ90mxmOHAl9S","fields":{"ID":50,"Authors":["recPwgCd6QGPvd5Fg"],"Title":"Incremental Development is what, exactly?","Content":"Recent Twitter conversation (paraphrased):\n\nFRIEND: There is this idea... I don't know who started it... that if you write code \"the right way to begin with\" that you'll never \"have to\"  change it...It's one of the most ridiculous ideas on software development, and the root of many dysfunctions.\n\nME: Every app I write that produces value that I never touch again is a win. Every app I write that I have to touch again is a loss, no matter how any of it is coded. You're missing something somewhere.\n\nFRIEND: But there are coders who think you code it perfectly the first time, then never touch it. If you have to touch it, you've done something wrong.\n\nME: Well hell, that's whack. But sure, you can, and should, deliver value you never have to touch again. How else would you do it? Once an app is started, it must always be maintained by somebody? Your goal should always be [Good Enough Programming (tm)](http://tiny-giant-books.com/Entry1.html?EntryId=recj67HoP8cKW5Eso). After that you can worry about Clean Code and the rest of it. Be good enough, then strive to be perfect.\n\nFRIEND: But any successful app is going to keep growing. People want new features. Ever take a look at the man page for \"ls\". The more valuable and used your app is, the more you're going to be touching the code.\n\nME: Oh boy. I think we have a situation here where business, backlog, architecture, and operations policy are all coming together in a huge 27-car pile-up. You are correct, but you are also incorrect.\n\nFRIEND: Huh? I'm just talking about incremental development, dang it!\n\nME: Yeah. No.\n\nFRIEND (Goes off mumbling something not appropriate for a family audience)\n\nLet's do a thought experiment. THIS IS NOT AN ARCHITECTURE. I'm just throwing together some UML to illustrate the kind of situation we have here. Let's say you're writing a banking app. Yay you! First big gig.They need three things done, so you code up some business components, stick 'em' in an app, and deploy them using whatever hot sauce of the week you're tweaking on.\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Simple model and backlog](2019-08-Inc1)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    You've got work! Congratulations! And it's a bank job, too!\n</figcaption>\n</figure>\n\nCool beans. The system does three things and we have four classes to do that stuff. Easy-peasey. How does that look on the server?\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Simple model and backlog](2019-08-Inc2)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    Just stick 'em in a box, drop them on the server\n</figcaption>\n</figure>\n\nWow. Your app was a huge success. And just like my friend predicted, because it was successful they asked for more stuff. Now you have \"Move\" and \"Transfer money to savings\"\n\nWell crap, that functionality doesn't go anywhere in the current model, so you'll need couple of new classes, like so.\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Simple model and backlog](2019-08-Inc3)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    Change is easy! It's incremental development! I got this!\n</figcaption>\n</figure>\n\nSo how does that look on the server?\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Simple model and backlog](2019-08-Inc4)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    Starting to get a bit crowded in there. We'll just use a smaller font.\n</figcaption>\n</figure>\n\nWhen you organize your backlog, code, and deployment like this, you're saying something like \"People ask me to do new stuff, so I find the right boxes to put it in. If it doesn't fit in the boxes I have, or if the boxes I have are defective in some way, I re-organize the boxes. Incremental development means taking new behavior for the system and putting it in an ordered, organized fashion in my codebase and IDE\"\n\nThis is what's known traditionally as incremental development. It just doesn't scale for very long.\n\nEven with TDD, more code means more bugs, more complexity means more chances to misunderstand things, more contexts for the same concept means more chances to have hidden conflicts that are never resolved.\n\nThere is a long list of what's wrong with huge monolithic development. You can use it, and it works great in some circumstances, but only when you understand these problems in-depth and work around them.\n\nSo how could we organize things differently? Let's see. Same project, first pass.\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Simple model and backlog](2019-08-Inc5)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    What kind of weirdo stuff is this?\n</figcaption>\n</figure>\n\nFrom the standpoint of the user's UI, it probably looks exactly the same, but instead of calling one place to do whatever the app does, the app calls different places to get different stuff done.\n\n*There is no linkage between the classes*. Or the structs, records, or whatever you want to call them. All they do is come, go, and tell us whether they're valid or not. That's it. Does an account need transactions in order to reconcile for the month? Well, then, the responsibility for that goes into the Reconcile Balance service. After all, these things change over time, but I can guarantee you that Reconcile Balance has to work no matter what changes. It's a user need, it's a controller if you like, so it handles binding.\n\nDoes that duplicate code? Sure! It very well might. At this point, however, I don't know and I don't care. I'm organizing my work around user needs, not perfect code. After a while, once the code stabilizes, we can do all sorts of cleanup. Clean Code doesn't go anywhere. It's just not as important as fidelity to the user needs.\n\nTo illustrate, let's introduce our change from before.\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Simple model and backlog](2019-08-Inc6)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    This is incremental development\n</figcaption>\n</figure>\n\nThere's a lot going on here that's not shown. Data has to move around, versioning is critical, and so on. But if these things fail, these services fail, and the services are the value the user is expecting. There should be hardly no impedance mismatch between what people expect from a system, how you code it, and how it might break. To put this in architectural terms, it used to be the dependency arrows began with controllers and went inside the system. Now the dependency arrows start where they belong, with business needs and understanding. This requires them to link to valuable functionality; nothing else.\n\nI'm not making a case for microservices here, although pure-functional, composeable, independent microservices map most closely to what I'm talking about. You can use this technique with any language and most-any deployment scenario you'd like. The trick is to map your code-change and deployment dependencies to just situations where the user needs a change done, and nowhere else in the system.\n\nYes, you have some linkage, versioning, data flow and other issues to manage, but you did anyway; you just didn' realize it or make it so explicit. This is a critical point: **Once you realize what's going on, you realize that all of the normal things that can hose up your application are still here, they're just in your face, where they should be. They're not all stuck in a component abstracted away somewhere. Instead you're using something like the OS to handle continuations, and that might actually be the best tool and place to do that in a modern development environment.**\n\nOne of the things my other friend Bob goes on about is business classes and IDEs. If you open up an IDE for a project, first and foremost you should see the kinds of things the project is working on! Not some abstracted-to-hell controller factory class or some crap.\n\nI get it. From the programmer on down, this makes sense. Too often the programmers get caught up in the wires and whistles and that's what they call coding.\n\nWhat I'm saying is that applications are not about wires and whistles. Sad to tell you this, but they're not about programmers, either. They're about that little stick figure guy called user. He scopes, pays, and reports status and progress based on the things he can do, not what kinds of business objects you as the programmer use to do the work. So what works for Bob works for me. Take it up a level. You shouldn't be putting your entire functionality at risk because of an incremental feature request. You should build and deploy, and interface with the users, in the way that makes sense to them, not you.\n\nFrom an outside standpoint, which is the only standpoint that should matter, incremental development is about selecting, paying for, and receiving new behaviors from your system. Your DevSecOps strategy should reflect that.\n\nInside your deployment units, your code can exist as a monolith, a script, a DSL, five COBOL divisions, or however you want it. From the business user to the deployment unit, however, the only mapping should be high-level business functionality; otherwise it becomes impossible for people outside your team, many of whom are paying or relying on your code, to reason about your working relationship. In this scenario, \"iterative development\" means iterating hundreds of times extremely quickly; in days or weeks. A programmer might change the code just a few times, hundreds of other consumers (mostly other programs) will transverse it over and over again, effectively fuzzing the work. If this is how you understand coding, then yes, you can code something quickly and walk away from it. In fact that should be your primary goal. If, however, your version of iteration involves a single deployment unit of non-trivial complexity with dozens of worker bees hovering about the scaffolding constantly making, tweaking, and revising functionality, then no, you can never walk away from something like that. You've created a development scenario where projects are created and never ended. That's not in your or your customer's best interests.\n\nLike most Twitter conversations, I believe my friend was making an important point. You can't and should never think you can code perfectly. That's whack. But like everything involving programming, by using language that was just a tiny bit vague or overstated, it opened the door to being misinterpreted. Twitter sucks like that. This essay is my attempt not to continue the dysfunctional social media cycle. Many thanks to my friend for helping me pick a topic.","Excerpt":"You're doing it wrong. Please stop.","Approved":true,"Categories":["recQbvNMbYGcFSc8z","recD6fV22IR0LSVdB"],"Tags":["recIPGRFebYI7QFwM","recLfkSmV5wJby8YI","recrv9vV7H2K5WayC","recSfRhJdArFwzoIa"],"StartDate":"2019-08-16T10:00:00.000Z","Blog":["recCGKQBlTWHqrGCu"],"Questions":["recYUu7t6kgQ63oZx"],"TemplateFile":"Entry1.html"},"createdTime":"2019-08-07T17:57:02.000Z"},{"id":"rec0iWZwgMsGafui6","fields":{"ID":49,"Authors":["recPwgCd6QGPvd5Fg"],"Title":"Learning to learn","Content":"\n<figure class=\"figure\">\n<div class=\"embed-responsive\" style=\"width:90%;\">\n\n![](2019-08-ScaryClown)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    It's just the dark\n</figcaption>\n</figure>\n\nWhen I was a child, my uncle scared the holy crap out of me. My parents stuck me in a cave. Then one dark and stormy night in November, my uncle returned and saved my life. This is the reason I wrote three books, why social media sucks, how science actually works, why political parties always form, how I learned to be a better programmer, why we're having problems with AGI, why aliens will probably be Baptists, and why George Carlin on his better days was far better than the Three Stooges ever were.\n\nBut I get ahead of myself. First my uncle.\n\nI couldn't have been six or seven. For many weeks my dad had been talking about a family trip to Maryland to see Bubby, one of his seven brothers. Bubby was blind, was married to a deaf/mute, had two grown children, worked at the shipyard, was generally-considered by the family as brilliant; my dad looked up to him a lot.\n\nA blind man married to a deaf/mute is an interesting thing in itself for any six-year-old, but everything he did was interesting too. Bubby could speak and hear, but his wife couldn't say anything or hear him when he spoke. She could sign using her hands, but he couldn't see her sign. So they stood next to one another, in this way he knew she was there. Then he could speak and she could lip read, or she could sign and he would feel her hands while she spoke. They were really cool.\n\nIt was amazing. I was entranced by my uncle, by his audiobooks (back then they called them \"books for the blind\"), his braille typewriter, the church they attended. It all mesmerized me. \n\nAlthough I was generally scared of the dark, they found me a place on the living room couch that night. I wasn't used to sleeping by myself, a point of much contention between my mom, dad, and me, but there was some light coming in off the street and from another room, and I was surrounded in a loving environment full of amazing things to learn. With enough reassurance I settled down. It was quiet and comfortable. I slept. The night was peaceful....at least until about 3am.\n\nI heard something. Opening my eyes, I found myself in a completely alien place. I had been abducted by aliens. There was nothing I saw that I recognized. I found this quite alarming, although I was too scared to make any noises. A dark creature moved stealthily through the shadows off the corner of the room. What was that?\n\nI didn't scream. I think I gasped. I couldn't breathe. The creature moved directly over to me, silently, like the shadow of a soulless panther.\n\n\"Daniel, are you alright?\"\n\nIt was Uncle Bubby, on his way to get a glass of water. He didn't turn the lights on because blind people don't use lights, silly. They get along just fine without them. Everybody had a good laugh at my expense. It was a great vacation and I went home, where a few years later the same thing happened again.\n\nI was 13. When I was 10, my parents had moved me out of the room I shared with my sister Joy and into a brand-new room they had built for me as part of a basement remodeling project.\n\nThere were no windows, and I really liked that. My room was on the other side of the house from everybody else, all by itself in the basement, well-insulated for sound; cool and dark. The only lights I had aside from the ones I turned on were the LEDs in my brand-new LED alarm clock. ($129 at Sears and that included an AM/FM radio!) It was a cave. It was _my_ cave. As a teenager, I needed and wanted a cave. Mom had decorated the entire room with Navy-themed accessories: pictures of the Blue Angels in their F-4 Phantoms on the wall, pictures of ships, a bedspread with anchors and chains, a flag-covered pillow. I loved mom, but it looked like I was still ten.\n\nI also loved that room. The only thing I didn't like about it was it was that it was so far away from the bathroom, I was still somewhat afraid of the dark, but eventually I grew to learn how to get up in the middle of the night, use just the alarm clock for light until I found the bedside lamp, then using prearranged points throughout the house winding my way silently up the stairs, down the hall, and to my goal. There was a pattern to it. Use the clock to get to the lamp, use the lamp to get to the door, and so on. I had a system that worked every time that I could rely on. I was at peace.\n\nI felt like a ninja.\n\nAfter a while, though, I got tired of my mom having such a direct impact on my decorations. I was thirteen, after all! So one day in a fit of manic industry I re-arranged every piece of furniture in my room. I took out the Navy stuff. I changed-up everything as much as I could. I was expressing myself. I was growing up. My room became mine.\n\nLate that night an electrical storm blew in from the mountains.\n\nI don't know what woke me, but at some point I was awake. I heard something. I opened my eyes. There was nothing to see. I sat up in bed looking for the familiar glow of the alarm clock, but it was just all pitch black. I got out of bed to walk to the door. I ran into a wall; a wall that by all rights shouldn't be there.\n\nAt this point I had completely forgotten that I had rearranged the room the day before, and in the dark of that night I found myself fully conscious and in a place that I did not understand and could not describe. It was just like when I was ten, but worse. Not only was I disoriented, I had no sensory input. There was just ..... nothing. I tried several times to get out of wherever I was, each time running into some obstacle that both shouldn't be there and that I did not understand. Was that a chair? What was that sound? What's this smooth thing I'm holding? Where am I?\n\nI guess I should have panicked, but I didn't. Instead I got rather angry. Why is the universe not conforming to my understanding of what it should be?!? This is impossible problem. I am trapped forever. Motherfucker!\n\nThen I thought of Uncle Bubby. Bubby managed to get around just fine not being able to see anything. He had a productive job, he went places he'd never been before, and he was able to learn and thrive. Surely I'm not _dead_, so there has to be some way to get out of this. Just think like he would. He does this all of the time. I can too.\n\nOf course, he never told me how he did it, so I had to wing it. I realized that I wasn't asking \"what does this place look like?\" That was an unanswerable question for me just then. There was no input. Instead what I needed to know was \"How do I learn to navigate places when I can't see or hear anything?\" That was a really, really *tough* question, but at least it was a question I felt I could sort out one way or another given enough time. Might be hours or days, I don't know. I guess I'd better get started.\n\nI made it out, of course. At least I hope so. I hope I'm not still there, rocking back and forth, having some crazy mental breakdown, alone and deep in the night. Getting out taught me an important lesson. You can't always get the answer to the question you'd like to ask. In many situations, the real work you have to do is figuring out how to learn enough to get to that question. We want to live in a world where we ask questions and authoritative answers are immediately provided, leaving us free of having to think through anything. Instead we actually live in a world where seemingly trivial questions don't have answers that are good enough to work for us and most of the interesting and fun parts of our lives becomes learning how to learn.\n\nI had a recipe. It didn't work. I desperately *wanted* a map, a simple picture of were I was and what was going on; a simple answer. What I actually *got* was some sensory input that changed as I moved around. The job was inventing my own system to use what I had to create that map. This wasn't following instructions, it wasn't having the facts and figuring it out on my own. It was inventing a system to come up with possible facts to then test and assemble into a plan.\n\nI can't tell you how to be a good parent. I've been a parent. There have been lots of books about what to do, but the real job of being a good parent is about learning how to act in a completely new environment you've never experienced before, just like me in my basement room. I can't tell you how to write code or build hardware to make that customer happy. There have been a lot of books claiming to do so, but the real job of making stuff that somebody wants? It's about finding yourself helping somebody do things you've never been exposed to, then making their lives easier. You're in a new, strange environment learning how to act, what's important and what's not important. You're learning to learn.\n\nWe'd like to live in a world where F=ma, that is, where everything is finite, completely-defined, deterministic, and where we just look up things in a dictionary and plug those things into a formula to find whatever answers we need. Instead, when we look around, we find ourselves in a world where the really important questions involve situations where we have to create systems to learn as we go along.\n\nWe need a science of progress. We need to learn how to learn.\n\nWhat is learning? When somebody says learning, I think of students, of school. I think of a bunch of students sitting in a classroom with a professor up-front teaching them. But that's not learning. That's formal education. One of the more interesting philosophers of the twentieth century, John Dewey, was a bit of an expert on learning. Here are a few things he said about it:\n\n- Education is not preparation for life; education is life itself. Education, therefore, is a process of living and not a preparation for future living\n- We do not learn from experience... we learn from reflecting on experience \n- Give the pupils something to do, not something to learn; and the doing is of such a nature as to demand thinking; learning naturally results \n- The path of least resistance and least trouble is a mental rut already made. It requires troublesome work to undertake the alteration of old beliefs\n- A problem well-defined is a problem half solved\n- The only way to prepare for social life is to engage in social life. To form habits of social usefulness and serviceableness apart from any direct social need and motive, apart from any existing social situation, is, to the letter, teaching the child to swim by going through motions outside of the water\n\nDewey had a lot to say about everything. He was an educator, so he wants to disambiguate education from learning. In his world, education is where a person sits in front of a classroom and learning is what the students do. We don't care so much about terminology as long as we're learning. We're interested in practical effects, not what each role should do, so we'll skip the differences in terminology.\n\nDewey, by the way, would have agreed. To him, education was habit in a social context towards some sort of useful goal. We develop habits. These habits help us both do useful things and help us un-learn things we previously thought were true. This use of habits to recognize something that's not working for us and replace it with something more useful is the basis of all positive change.\n\nThat's an important concept.\n\nWe need to take it apart because separately each piece doesn't amount to much. There are three parts: habits that enable both performance and unlearning, social context, and working towards some useful goal. Talking about habits by themselves leads to self-help books like \"Seven Habits of Highly-Effective People\". I love self-help books. They always make me feel good reading them, but then I must not have been helped that much because pretty soon I'm reading a new one on basically the same topic. \n\nIf talk only about social context, we end up in management and leadership territory. There are a lot of management and leadership books too. They also tend to be like self-help books; intellectual popcorn. Have some now, have some later, have some at the gym while you're exercising. Munchies are always good. \n\nTalking only about goal achievement is more interesting because goals can be definite and finite. Most programming books are about technical goal achievement: code with this tool, using this style, in this process, and you will achieve your technical goal. These are probably the most useful books because they never talk about how you're supposed to figure out what to code, they just talk about coding it. The problem has been simplified to the point of mechanical rote. These bits in this order are pretty good! These bits in that order are pretty bad! It's very hard to screw that up. Follow the recipe. This is good, this is bad. Do this and your bits will always be well-ordered. Very good!\n\nBut when you finally start adding people into the equation of goal attainment, and this always happens whether you realize it or not, the whole thing falls apart. \"Meet your sales goals in three months!\", \"Master the Interview Process\", or \"Pick up the date you've always wanted at the local bar tonight!\" Not only do these books reduce other humans to just sort of bit players in a drama that you star in, they also tend to be not-so-effective. But hey, if you like them, read them; there's more coming.\n\nSitting in that dark room, I thought of my social context. Uncle Bubby could do this; I've watched him do it. My family is nearby and at some point they'll come get me. I thought about my goal. If I can make it to my door, once open there will be light. If not light, there will be at least a new and different puzzle to solve instead of the current one. I thought about my habits. Getting up and walking towards what I thought the door was did not work anymore. I couldn't find a light. I had been trying several things that did not work.\n\nSo I started from scratch developing new, tiny habits to solve this particular problem. \n\nThey worked, and as a result of that experience, growing up at night I never cut a light on again. My new habits did not require lights in the house.\n\nI was no longer afraid of the dark.\n\nTaken separately, these three are really fluffy concepts. Put together with some rigor, however, they turn are life-changing. Changed my life. I learned to live without lights. They can change yours, too.\n\nLearning to learn is one of the most important topics we can talk about. Because of that, I wrote three books. \n\n<div>\n<div class=\"embed-responsive embed-responsive-16by9\">\n<iframe class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/gYMnpG919Kw?rel=0\" allowfullscreen></iframe>\n</div>\n<p class=\"figure-caption text-center text-muted\">\nA preview\n</p>\n</div>\n\nThe first book, Info-Ops, is about *how do I learn how to create tech to make this person happy?*. You know already programming and/or hardware assembly. There's a person in front of you that has a need, but they work in an area you've never experienced before. How do you learn about them and the work they do so that you build the right thing that they need and not something you guess is what they really should have? \n\nThe second one, Info-Ops2, is about *how do I learn to be a better programmer?* You know tech. You don't worry about figuring out the right thing to do because somebody always tells you. There are a ton of languages, frameworks, technologies, techniques, and tech movements out there. How do you know that you're working towards being the best programmer you can be? What books do you read? What skills should you learn? How do you know if you're doing it right?\n\nFor a long time I thought the answer was something like \"Write cool stuff that looks woefully impressive and that other coders will love.\" But that turns out to be just another version of the \"Get laid tonight for sure!\" self-help books, where everybody else is just a bit player in your own little drama. In this case instead of trying to get laid you're trying to impress other coders. Using this attitude, the other coders in the world exist only for purposes of telling you how awesome you are. It's probably a great way to get invited to conferences, but it's not a great way to live. More importantly, it actually makes you much worse programmer over time, not a better one.\n\nThe third one, Info-Ops3, is about *how do large groups of people and machines learn together?* How does generic learning happen at scale? Now we've come to AI, social media, program management, aliens, and all the other stuff I mentioned in the first paragraph, but we arrive here only after understanding the rest of it. Otherwise we would have no context. \n\nWe're taking a rollicking trip from swinging a hammer building a backyard deck to cyclomatic complexity to neuromorphic AGI. It's all related because it's all about the intersection of habits, social context, and goal attainment. It's about a lot of other stuff too: we have a toolbox to fill up and some cool tactics to discover when using them. But it's all about learning to learn.\n\nThat night, in my 13-year-old mind, my uncle saved my life. Now let's see what his lesson can do for the rest of us.\n\n<div>\n<div class=\"embed-responsive embed-responsive-16by9\">\n<iframe class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/EAYXkWPPXlc?rel=0\" allowfullscreen></iframe>\n</div>\n<p class=\"figure-caption text-center text-muted\">\nA preview\n</p>\n</div>\n\n","Excerpt":"Plato's cave doesn't have a campfire","Approved":true,"Categories":["recQbvNMbYGcFSc8z"],"Tags":["rec8Q7Sn8p6DNLNKJ","recfhydFF7ur53pTS","recLfkSmV5wJby8YI","recrv9vV7H2K5WayC","recSfRhJdArFwzoIa"],"StartDate":"2019-08-07T11:00:00.000Z","Blog":["recCGKQBlTWHqrGCu"],"Questions":["recaGbPdPpAx6Pmj0","recbHiSxqyBiNiuDv","reckKRruy3mvt092D","recbmGBMrftbwj0Va"],"AdminNotes":"Same","TemplateFile":"Entry1.html"},"createdTime":"2019-08-07T15:24:23.000Z"},{"id":"recLg6diOYbzb1zNY","fields":{"ID":48,"Authors":["recPwgCd6QGPvd5Fg"],"Title":"Meaning and Somethingness","Content":"# Why does everything related to tech have to be so complicated?\n\n<div>\n<div class=\"embed-responsive embed-responsive-16by9\">\n<iframe class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/bZe5J8SVCYQ?rel=0\" allowfullscreen></iframe>\n</div>\n<p class=\"figure-caption text-center text-muted\">\nWhen you program, life is always like this\n</p>\n</div>\n\nWhat do words mean? You never worry about it when you're a baby. You just use them. Then, if you're lucky, one day you go to school where they teach you how to write words. Later they teach you that if you want to know what a word means, you look it up in a dictionary. Even later, if you're more lucky, you end up in a field that has self-consistent, tightly-defined terms, like mathematics. There you can build self-consistent, logical languages from first principles. If you're unlucky, you end up in a field like law. There they teach you that words can mean anything that you can convince a jury of your peers or a panel of judges that they mean. If you're more unlucky, you end up in a field like computer science. There you meet and try to help folks who do all sorts of things. They all use the same words, but when you go to translate their universe into programming, you begin to realize that even though the sounds and spellings might be the same, the same word can take on drastically-different meanings based on its social, cultural, business, and emotional context.\n\nThis gets extreme in situations we call \"word salad\". In technology, there are a bunch of words that sound good together, like \"Customer Resource Management System\", \"Machine Learning\", \"Blockchain-Powered\", \"User Friendly\", or \"Virtual Provisioning\". To the outsider these might sound like wholesome hot sexy coolness, but to the insider they can mean so many things that most of the time they mean nothing. You'd think that the more of these words stuck together in one phrase, the more constrained the meaning, but just the opposite is true. Given enough of these little lexical licorice sticks of liminality, a good marketing department can write an enticing, exciting description of a product without actually conveying anything at all about the product itself. A lot of words, not much meaning. Word salad.\n\nWorking in technology, you learn this almost as soon as you start; word salad is probably the thing nerds like to joke about the most. Later on, though, as you write more and more self-consistent programs in various domains, you slowly begin to realize that it's not just the bulky bullshit buzz blurbs. Hell, it can be things as simple as \"Customer\", \"Balance\", or even \"Is\". Then, if you're really unlucky, it finally comes to you that you've ended up in life where the lawyers began: words don't mean anything. Or rather, they mean all sorts of things, things you would never expect. One word can mean so many slightly-different things that you become suspicious of every word, every nuance. So, you need a program to reconcile the accounts by Tuesday? What exactly does reconcile mean? And what do you mean by accounts? This Tuesday, or another one? Every Tuesday? All the accounts? What time Tuesday? Who exactly needs it?\n\nYou don't get invited to a lot of parties. If you are, they find you in the corner, muttering to yourself that words don't mean anything. All of that suffering, and you could have went into math.\n\n---\n\nLife can be so much better. Take for example a 17-month-old baby. The baby knows about 17 sounds, none of which anybody outside of their family understands. There's narwl-walker, oomph-blop, and something that sounds like Uncle Fred sneaking a fart. The family can take this baby, head full of mush, out shopping one afternoon, and when they return? The baby now has a dozen new items, each of which it asked for, in detail, and each of which fit into some sort of larger master plan only the baby knows. This baby is doing a better job than you are with your account reconciliation.\n\nIs everybody better at this than you? Is that possible? If so you're going to be even more of a bummer than you currently are. Let's look at a different example. Take for example a group of 100 top scientists, all with multiple PhDs and perhaps the best in their field. Put them on a project. Fund with hundreds of millions of dollars. Give them three years to work. It's quite likely that at the end of three years nobody can agree on what the simple phrase \"case management\" means. Good grief, it's almost like words have nothing to do with it. Maybe the more smart people you add to any effort, the less likely it is to succeed?\n\nThat can't be true, however. Large teams of really smart people built the super-collider. They put men on the moon. It can't be the people, although it has something to do with them. It can't be just the words, although they play a key role. *It's something about the way that words are used that somehow brings both meaning and success or failure*.\n\nSo what is it? What works? It took thousands of years to answer that question. Socrates had the method but didn't understand it. Wittgenstein figured out what we were doing wrong but didn't know how to fix it. But you, the humble programmer, have been kicking this problem's ass over and over again every day without even realizing the miracle of what you've been doing.\n\n## Metaphysics gave us modern life\n\nThe ancient Greeks had a lot of things going for them. They lived in mostly isolated valley communities that both had strong social ties and exposure to a vast array of people and cultures due to easy their access to the sea. Farming and trade had developed enough so that many people had free time, especially the children of wealthier merchants. There was enough of a common base of a language such that they could converse with almost anybody.\n\nSocrates said a lot of really famous things. One of them was \"the definition of terms is the beginning of wisdom\". Plato says Socrates never wrote anything down, believing that writing actually hurt understanding. Instead he would hold his \"physics\" lessons in-person and it would all be spoken. Then there would be metaphysics. \"Metaphysics\" simply means \"after the physics\". After the lessons were over, Socrates and his students would gather, go walking, and have a free and open conversation about all of this wondrous new stimuli Greek society was experiencing. How do we assimilate all of these cool new ideas into our culture?\n\nGreece around this time became known as the birthplace of philosophy. Philosophy, in turn, has been called the Mother of all Sciences. Why call it that?\n\nAs Socrates was trying to explain, philosophy led to the common definition of terms enough that people could devote their lives to studying a topic where most educated people agreed mostly on what it was. We started learning enough about certain topics to come up with systems to learn more. If you were interested in light, you didn't have to start from scratch. You could talk to people and get a good idea of where and how to begin. As a species, we started incremental learning, where it kept developing over time. Somebody called that \"Standing on the shoulders of giants\"\n\nThis was cool. Over the centuries a lot of folks have talked what happened. A lot of people talked about why things were done and the flavor and style of different philosophers, the impact they had on life. A lot of people talked about about *how* philosophy was done, but then it was mostly about the people, the classes, the history, and the way the terms evolved. So much of what happened was verbal, in-person, informal, relaxed, and not recorded. I can tell you about the Sophists and how they related to the Socratics. I can tell you how things happened and how it all worked out. But I can't tell you what it was like hanging out with Socrates and his buds walking through the stone back streets of town looking for a couple of brewskies and shooting the shit. We don't know. And sadly, this metaphysics is really how the actual work of philosophy happened.\n\n## Specialization, isolation, and silos started taking it away\n\nThen something unexpectedly slowly happened over the next couple of thousand years. It was surprising at the time but isn't surprising at all to any programmers that have spent any time in various organizations: some groups did well and some groups self-destructed.\n\nAt the heart of this self-destruction was always specialization and isolation, what we call \"silos\" in the corporate world. Pythagoras did some really cool stuff with math, but like every other philosopher, he took his own ideas too far, thinking they applied in places they did not. There was not only a Pythagorean school, the was a religion, a cult, a way of life. It became a self-contained community. It didn't have a lot of creative input from the outside world.\n\nAs a technology person, if you've ever watched large organizations decay over time, you'll know how this plays out. At first, people who silo, specialize, and isolate themselves start producing far above everybody else. After all, we've removed their distractions and they're only focusing on the important stuff now. But slowly, over time, siloed system become self-validating, cutting themselves off from forces outside of their control that might tell them they're doing something that's helpful or harmful. They begin to decide these things on their own, based on their own internal criteria. Why are we upgrading to Oracle 7 from Oracle 6? Because that's what we decided we're supposed to do. Why do we have furniture police that tell us what we can do with our furniture? Because this is what the furniture police are supposed to do. Like the ancient Greeks, we've established the little isolated communities, but we don't have the constant chaotic, creative mix of new, useful stimuli.\n\nDisciplines that moved in with each other and mixed it up with the outside world? They evolved over time. Those that became more religious and cult-like, immune to criticism or input from the external world ended up developing more and more arcane terminology,  rituals, and initiation rites. The early university was great not only because you could meet a lot of smart people and learn stuff to change in the world, it was great because all of those smart people were at the same time learning from one another about things they had never heard of before.\n\n## Russell thought we needed more formalism while Wittgenstein saw the problem as hopeless\n\nBut as the number of disciplines, scientists, educators, and institutions grew, intellectual life got specialized and siloed anyway. That's because we had a hidden assumption that ideas worked the same as physical processes. If you own a business moving coal around, you can break up the task into physically-separate parts and optimize for each part. Doing that simultaneously optimizes the overall system. We thought knowledge work was the same way, but as it turned out, knowledge work is infinitely divisible. If you master html and css this year, next year you'll need that plus microformats, sass, and webpack. The following year all of that decomposes even more, and so on. There is no end, and there's no alarm that goes off to tell you that perhaps becoming an expect in the history of tagged markup languages is not going to provide anything good to society. (But your other tagged markup language friends may be very impressed with your work)\n\nSo what do we do? How did we end up like this?\n\nIn the early 1900s Bertrand Russell was a really rich professor dude who taught philosophy. He thought that the problem was that people were being too loose with how they defined things. More rigor and logic would give us a clear ontology of how the sciences and life related to one another. That would allow philosophers to continue being science's mommy, nurturing whatever progress that was left.\n\nSidebar: what's an \"ontology\"? An ontology is basically a system of organizing and grouping things so you can understand them better. If you remember libraries, they had something called the Dewey Decimal System. That's an ontology for organizing books. If you like birds, there are really cool books that let you classify them. That's an ontology for birds. Even things like database diagrams are ontologies. This table is related to this other table. Ontologies are systems of organizing concepts to create shared meaning.\n\nRussell had a student, another smart rich dude, but a bit of an oddball. A weirdo. He gave up all of his family's money. He took this philosophy stuff extremely seriously, wondering how he could move it forward while keeping it honest and pure. His name was Wittgenstein. At first, the professor Russsell going to reject this weird provincial kid Wittgenstein as a possible new student, but then he realized that Wittgenstein was really extremely smart and hard-working. Whatever he committed to working on, he wouldn't let it go until he finished it. So Russell recommended him as a student and the two began their tumultuous relationship.\n\nWhile Russell dove into formalism, rigor, and logic, which is how atomic, well-defined rock-solid concepts relate to one another and can be used together, Wittgenstein went the other way, trying to figure out exactly how people understood what words meant, the topic of this essay. Basically they went completely opposite directions. It couldn't have been pleasant. In the end, Wittgenstein ended up working for poverty wages teaching an elementary school out in the boonies while he kept at it. Russell stayed a rich, lazy, smart professor. He produced and developed a lot of new ideas that we're still benefiting from. Neither one was right or wrong. They were both right. At the time, however, they looked a lot like they were headed in opposite directions.\n\nWittgenstein kept grinding on the problem. He eventually reached a startling conclusion: For the most part, each of us speaks our own, internal, self-created language based on our unique life experiences, it's just that we agree mostly on most stuff and it all kind of works out. Once you start trying to split language up and make it all formal, however, you realize it's terribly inconsistent. As you connect more dots and apply more logic and rigor, you finally figure out that it's even irrational and illogical. In fact, it's impossible for it not to be irrational and illogical. Human language ain't math.\n\nWittgenstein, being the humble philosopher he was, announced to the world that he had \"solved\" philosophy. yay. There was no need to keep doing it anymore. His insight was that as we began writing languages down, and then we started writing math and geometry problems down, we naturally started mixing the two up. We started thinking they were the same thing. After all they both were words on paper. A dog is a mammal and a mammal is a animal, therefore a dog is an animal.\n\nIn a way Wittgenstein was agreeing with Russell: we kept using words in a loose, informal way to convey rigorous mathematical concepts, and it works well enough until it gets to a certain scale. Then suddenly everybody's busy but nobody's getting anything done. But where Russell thought that you could just try harder, be more like a machine, Wittgenstein realized that this was a fool's game. Everybody had a tiny different idea of what each word means, and that was fine. Even the most common words, like \"cat\", can mean subtly-different things to different people. This wasn't a logic problem. It didn't mean they were completely different meanings, either. That kid at the mall could point at a lollipop they wanted and make a sound like \"meanulmomp!\" and who cares about the spelling or the dictionary? It got the lollipop. That's the way life is. Everything works well enough most of the time; nobody notices.\n\nWe were expecting too much. We have a lot of assumptions about language that don't hold up.\n\nSo folks ignored Wittgenstein. Russell was the popular guy and had all the new exciting ideas. Mainstream science and philosophy gave us modern life. We made it all computerized, and now it's all software. Software is eating the world.\n\n## ***Programming is applied philosophy***\n\nBack when philosophy and science existed mostly as words handed from one generation to the next in written form, it was possible to amass enough of a web of meaning for any one general field for a body of practitioners to gain useful applicable knowledge for the rest of humanity. But as philosophers found out, and science is now finding out too, it's also possible to create not only webs but islands of meaning, such that localized progress can appear to be made without having any impact, positive or negative, on mankind as a whole. We mind our knitting so well that nothing ever gets knitted.\n\nWe programmers have this problem, but we not only have it, we have it over and over again with each new domain we absorb. We start with (spoken) languages, jargon, and cultural knowledge, combine various tribes together, create a mezzanine language among ourselves, then translate all fo that into math. Hopefully it's provable, rock-solid math. But however we do it, we deal with mapping ideas to bits.\n\nIn the entire history of mankind, nobody else has ever had the job of doing that over and over again across dozens or even hundreds of sciences. Instead, the typical approach was to become good in one domain, then continue to specialize. In this sense, technology development is applied polymathematics.\n\nWhat can we see when we look across the world of all programming, is that programming is not just the mother of sciences. We're using programming as a formal ontology to make math/science-like systems over and over again, tens of thousands of times. It's like a new set of old Greek dudes in togas is born every time a hipster web team walks into a client's office and asks \"What do you guys do here?\" \n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Scintillating Grid](2019-07-ScintillatingGrid)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    Which dots are black? Which dots are white?\n</figcaption>\n</figure>\n\nEver see the scintillating grid optical illusion? It looks like you can see every other black dot except the one you're looking directly at. Meaning is similar in that whatever the concept under observation, it appears like some analysis can work out the problems. The other ones, farther away, don't need any work. Those edge/buffer concepts are all set in stone. But then, given time, when you look at those, you realize that no, actually there's some problems over here too. That area you were looking at before? Now they're the ones all fixed and unchanging.\n\nThe lesson here is that there is a cognitive limit to the things that you can simultaneously ponder about their meaning, relationships, and relevance to any one situation. After that limit, it's all just \"common knowledge\" or received wisdom. It has to be that way for reasons that are not important now. But then you realize that it's all a web, we're all living in our own constructed grid that's different, ever-changing while we're not looking, and irrational, illogical, and inconsistent. The goal in programming stuff for people you're learning about is to align both the concepts under observation and the \"given\" concepts among several of us such that we can erect a language scaffold sturdy enough to make progress toward some common goal.\n\nThis looks a lot like Russell but it's not. It's Wittgenstein. I'm not talking about the program/technology itself. I'm talking about the process of moving from learning new stuff to creating a rigorous and logical language around it.Socrates. Mankind did it a few times before we invented computers. We coders do it everyday, without even knowing what we're doing or much caring about how it gets done.\n\nWe fail when we expect too much from language. We succeed when we're aware of how and why language is broken and work around it.\n\n## The Dance\n\nThe good news is that we humans are language-constructing machines. That little baby got its lollipop. Language creation is a natural and probably the most important part of our social programming. We've been doing this all along without noticing or understanding it. This is why it took us so long to figure out what was wrong. Some folks are still struggling with it. It wasn't until self-contradictions and stagnation reached almost crisis levels, or at least the point where oddballs like Wittgenstein would notice it, that enough words had been put on paper that we could step back and see what we were doing. Even then, there was really only one example, science itself, to show how it worked.\n\nThink of learning as a dance. The value is in the application. You walk into a large hall with other people and notice that really good dance music is playing. People are moving around the dance floor. So you say to your partner \"This is great!\" and jump in and start dancing.\n\nWhat's great about it? \"There is a pattern of activity that I find pleasing that I can join in and feel as if I am accomplishing something of value\"\n\nExcept in Wittgenstein's case, all the people were dancing, but they were all dancing to different songs and in their own invented way of dancing. Now there's nothing wrong with inventing your own songs and dance moves, mind you, but Wittgenstein was the guy that pointed out that this was what was happening.\n\nWittgenstein didn't get invited to a lot of parties either.\n\nNow, a new dawn. Now, we can begin discussing \"Can we all listen to the same music?\", and \"Who likes Jazz?\", and so forth. We've opened up a new class of exploration that didn't exist before. We're finally joining how-we-interact-as-primates with how-we-can-make-rigorous-languages-that-do-things-mathematically in a way that we never could before. We couldn't see it. Now, we can.\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![The Red Pill Scene from The Matrix](2019-07-MatrixRedPill)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    Make your choice\n</figcaption>\n</figure>\n\n## Now that you've taken the red pill, how far do you want to go?\n\nThose ontologies that we talked about, where you have a way to sort out birds or where books go in the library? Creating ontologies has a direct mapping to creating OO software. When I say, referring to some C++ code, that a customer has an account that has some transactions, it's not just that I'm talking about things in the real world. We used to teach that, and it can be true, but it sure seems mind-bending enough to screw folks up. What's really crazy is that what I'm really doing is saying something like \"we coders decided that traversing customer was more valuable intellectually than transactions, and that for the most part we would talk about transaction in terms of which they were in\"\n\nThat's ontology.\n\nYou could graph that out a few other ways, all equally valid, but each would have its own ontological meanings. And we all do, just inside of our heads, whether we actually draw real graphs or make real code or not. That's Wittgenstein. The art of programming computers has just made it visible.\n\nEven more cool is that means things like the Liskov Substitution Principle, the Law of Demeter, or the Dependency Inversion Principle are not just coding best-practices; they're actually a commonly-agreed-upon way for groups of people to reason about ontologies based on usage. We've never ever had that kind of agreement before in the history of our species.\n\nIt gets better. Moving to functional programming, there are a ton of apt analogies and lessons there as well. Functional programming is a formal map of value delivery. Things like DSLs, functions, tokenization, DDD, and the Onion Architecture actually dive deep into how we can work better together.\n\nIn the rest of this book we're going to talk exclusively about being a better programmer. In the third and final book we're going to take the things we've learned from the first book and this book, now that we've taken the red pill, and talk about org and societal change. It's going to mind-blowing, I promise.\n\nBut for now, you know why being a better coder is much more important than simply learning how to sling text around in your favorite IDE using keyboard shortcuts. You're going to change the world, bub. So let's look at being a better coder in the real world, using real code, in a way completely different than we've ever considered it before. We're not just going to be better programmers, we're going to learn to think of programming in a completely new way.\n\nLet's get our Wittgenstein on.","Excerpt":"Now that you've taken the red pill, how far down the rabbit hole of reality are you ready to go? or Why programmers are the true masters of the universe.","Approved":true,"Categories":["recQbvNMbYGcFSc8z"],"Tags":["rec8Q7Sn8p6DNLNKJ","recSfRhJdArFwzoIa","recrv9vV7H2K5WayC","recfhydFF7ur53pTS"],"StartDate":"2019-07-30T07:00:00.000Z","Blog":["recCGKQBlTWHqrGCu"],"Questions":["recaGbPdPpAx6Pmj0","recP7QjaaAmQLGdzy","reck1CpVvULaFWVba","recMMoTy278CTdyBI","recbmGBMrftbwj0Va"],"TemplateFile":"Entry1.html"},"createdTime":"2019-04-09T17:37:47.000Z"},{"id":"recgcpfuOFUesUpRy","fields":{"ID":47,"Authors":["recPwgCd6QGPvd5Fg"],"Title":"Technology is Heroin","Content":"*Ed: From 2009. This is believed to be the first mention of the combination of evolutionary pressures+addictive content as a driving force in technology creation*\n\nBy Daniel on February 6, 2009 1:19 PM\n\nIn 1850 people didn't know how their favorite symphony sounded.\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Bottle of off-the-shelf heroin anybody could buy at the turn of the 20th century](2019-04-heroin-bottle)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    Heroin was available in most pharmacies to anybody who wanted it\n</figcaption>\n</figure>\n \nBack then, it was common for musicians to work hectic schedules and perform multiple shows in a row. Instruments were frequently out of tune and good, consistent timing was fairly new. In addition, going to the symphony was a big deal: you dressed up, you hitched up the horses, you went into town. \n\nYou might only hear your favorite symphony 5 or 6 times in your life. Each time it was probably slightly in a different key, with a slightly different tempo, played with slightly different instruments, and each time you actively strained to hear and remember how it all sounded.\n\nYou would sit very attentively, absorbing each and every note and drumbeat of the symphony. It was a play, a painting, an imaginary world come to life, and you were living in it. It was magic.\n\nWant some fun diversion? That was different too. You could read, which required an above average education and concentration. The more you read, however, the more you could read, so it was a self-reinforcing pastime. You could perform music, which also took years of study and was self-reinforcing. Then there were games, which mostly either involved physical exercise or concentration.\n\nEverything back then took work and time. In rural America, it wasn't unusual to walk five miles to a friend's house to play a few games of checkers. Life was monotonous and physically challenging. In the countryside there was no plumbing and electricity hadn't been invented yet. You spent a lot of time hauling around water, chopping firewood, planting and tending crops. It took nearly continuous physical activity. Leisure was no different: it took time, work, and active minds.\n\nWant to socialize, hang out with the buds? It was a big deal, a special day. You'd either walk a ways or get on your horse and ride. If it were a really big day, like election, you'd hitch the wagon up to the plow team. It was a lot of work and hassle, but eventually you'd end up at the dance, the election, the church, the pub, or wherever. There would be drinking and story-telling ugoing on for hours on end. Hey -- these were your friends and it took a lot of hassle to spend time with them. For instance, when the American Colonies were formed, Ben Franklin and a few other delegates threw a kegger before everybody else arrived that went on for several days.\n\nThe chemical diversion for the vast majority of people was alcohol. Who can forget Franklin's famous quote about wine? \n\n<div><blockquote style=\"margin-left:5rem;margin-right:5rem;margin-top1.5rem;margin-bottom:1.5rem;font-style: italic; font-size:110%\">Behold the rain which descends from heaven upon our vineyards; there it enters the roots of the vines, to be changed into wine; a constant proof that God loves us, and loves to see us happy.</blockquote></div>\n\nIt wasn't an ideal life by any means, but by contrast within 50 years the devil himself paid a visit to western society and it made those days look like a picnic.\n \n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Cocaine toothache drops](2019-04-cocaine-toothache-drops)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    Like the other chemicals before it, cocaine was widely-praised as a miracle drug, enabling people to do many things they could never do before\n</figcaption>\n</figure>\n\nFast forward. It's 1900 and you're in pain. As a Civil War vet and in your late 50s, most of the time you spend lamenting how lazy and dumb the current bunch of youngsters are. But you're old: Being 55 then is like being 75 today. Death was a very familiar sight. For most of history, toothaches were a common cause of death. You'd get an infected gum, then sepsis would set in. A few days later you're dead.\n\nHelp is on the way, however. The American Civil War saw the first use of morphine for pain relief. It's impossible to overstate what a difference it made. The opiates were truly miracle drugs. Got a bad war injury? Morphine could make you feel like you were floating in the clouds. Got a bad toothache? Put a little bit of cocaine on there and the dentist could pull it out while you laughed the whole time. How about a bad cough? Nothing like Heroin to fix up a coughing fit. \n\nPeople who led dank, miserable lives because pain kept them suffering suddenly felt wonderful. They felt engaged, energized, and plugged into society. Heroin comes from the German heroisch, which means heroic, because in field studies people using the medicine felt \"heroic\" Women were encouraged to use opiates for \"female problems\", marital issues, boredom, and just for something fun to do. Nothing like a little blow to liven up a Victorian tea party, right? And you could buy the stuff anywhere. It was legal and cheap.\n\nThe wildly popular Thomas DeQuincey's \"Confessions of an Opium Eater\" described how good opium was:\n\n<div><blockquote style=\"margin-left:5rem;margin-right:5rem;margin-top1.5rem;margin-bottom:1.5rem;font-style: italic; font-size:110%\">I do not readily believe that any man, having once tasted the divine luxuries of opium, will afterwards descend to the gross and mortal enjoyments of alcohol.</blockquote></div>\n\n\nI take it for granted That those eat now who never ate before, and those who always ate now eat the more.... What I contemplated in these Confessions was to emblazon the power of opium -- not over bodily disease and pain, but over the grander and more shadowy world of dreams\n\nThen people woke up. They looked around and found large sections of society were hooked on dope. People spent their time zonked out. Work in the fields didn't get done. People who were high didn't socialize like they used to.\n\nDeQuincey wrote a later book called \"Miseries of Opium\" in which he went on at length about how opium completely destroyed his life. But nobody bought that one.\n\nYou'd think that people would be pretty quick to recognize that opiates were a problem, but that's not how it actually happened. It took decades of zonked out Civil War vets, housewives who were so stoned they couldn't walk around the house, and professional doctors and lawyers -- professionals -- who were completely unable to perform for people to take notice. What finally drove change was the fact that life then was much more time-intensive. Nobody cared if you spent your days zonked out, but if you didn't plant your crops and your family was starving the community had to step in whether it wanted to or not.\n\nThe problem was that nobody had ever dealt with something like that before. People just assumed that new drugs -- the new technology -- was something that performed miracles. It was progress. It was the natural course of things. Sure, there might be some side effects, but we'll eventually figure it all out. Eventually, people thought, we'd work it out. Like everything else, it was simply a matter of moderation. There would be some new drug that would treat addiction in general and that would be that.\n\nOne of the uses of morphine, after all, was to treat alcoholism. And one of the uses of Heroin was to treat morphine addiction.\n\nBy 1910 it was becoming apparent that while opiates were a miracle cure, we had to get them out of the hands of a public which was terribly hooked on them. Either that or start a generational pattern of addiction that would destroy the country and waste hundreds of millions of lives. Heroin was strangling out time, our productivity -- our souls.\n\nIt was a terrible, gut-wrenching decision that we still argue about to this day. Who is the government to tell me what I can and can't put into my own body? And in the end, people just did as they wanted anyway. Making drugs illegal probably saved the country, but it also brought on organized crime, a drug subculture, and made generations of pill-poppers since look like hypocrites. It changed our definition of what a productive, good life is all about. What it meant to be human.\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Social networking collage](2019-04-social-networking-collage)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    Social networking icon collage from 2008. When this essay was first published, the most common counter-argument was that it didn't matter because Facebook and other providers would be replaced very quickly with newer applications. Instead of market leaders changing based on fad or utility, what happened was that the market sorted itself out based on addictiveness, with companies able to master the dopamine delivery then taking over the business models of others\n</figcaption>\n</figure> \n\nIf it hadn't been for the record player, it might not have happened again.\n\nOn a warm summer's day in 1877 Thomas Alva Edison began shouting \"Mary had a little lamb\" into a strange contraption that would change the world. For the first time, a voice was recorded on a medium that allowed it to be played back, either a few or a million times. This meant that you could experience music -- wonderful, glorious music -- simply by placing a cylinder into this machine and starting it up.\n\nAt first, people used the phonograph like the concert hall. There were \"phonograph parlors\" where people would dress up to go hear phonographs \"performed\". Later, however, the technology improved, as it always does. Everybody got their own home phonograph.\n\nRobert Greenberg, lecturer, composer, pianists, and currently Music Historian-in-residence with San Francisco Performances, notes that music went from being an active endeavor to a passive endeavor.\n\nThis bears repeating. Music went from being something where you actively paid close attention to a complex piece of art to just another sound in your environment. Music is all around us now -- though we take it completely for granted. It's background noise. But this is a very recent thing. It used to be that you went to the music. Now the music comes to you, whether you're paying attention or not.\n\nThat means that music, instead of getting more and more complex and intricate, is now evolving along a different line. It's sonic evolution: survival of the fittest. Music competes with all sorts of other things for your attention. For a song to make money, it has to cut through the clutter and instill in you a \"quick hit\" of something that feels good. That's why rock-n-roll and other drum-heavy music beat out the big bands. In general, the beat wins out over the tune. I can hear a guy playing hip-hop coming from 200 yards away. The beat cuts through the sonic clutter. Creating music now is a survival of the fittest contest. The goal is to take a mind engaged in something else, capture its attention, and \"turn it on\" to some cool grooves and lyrics for a while. The more you can engage distracted listeners and the happier they feel, the better the music.\n\nThe phonograph was followed by radio, which was a big hit because it could take live music and put it anywhere. At first it was the rebirth of live music. But that only lasted a short while.\n\nThen came television, which promised not only to compete for our aural senses but also to compete with sight as well. \"Don't turn that dial!\" has become cliche: whatever you do, keep your eyes peeled on this station.\n\nEvolution is a wonderful thing. Start with some initial conditions, put in a need to survive, and evolution will find some of the best solutions possible for survival. If the initial conditions are \"I have a product. The audience is not paying attention. Unless they pay attention I will die,\" then I will find the most optimum way of taking a non-participating audience and make them involved, make them happy. If not in this generation and this technology then in the next one.\n\nWhen I was a kid people lamented the fact that folks spent too much time on TV. Like every generation, the old folks told us that we were lazy and stupid, and wasted our time a lot. But hey -- it's not like TV gave you the shakes, or made you sick or killed you. It's just a bunch of images on a box. Hell, it's educational. And it's all voluntary. Nobody makes you spend your time there. If I remember correctly, I spent just as much time out in the yard running around as I did watching TV. But the evolution of media was still young.\n\nThen came video games. Cool little pieces of programming designed to let you spend as much time as possible having fun. Once again, the games that were short or non-addictive died off. Evolution kept evolving games better and better at taking your time and turning it into joy.\n\nThen came the internet. It was like radio was to music -- it allowed all of this fun game time to be spent with other people. We can now play dynamic multi-player games with millions of other people around the earth. Instead of hitching the horses to go to the dance, we can flip a switch and see all of our \"friends\" of FaceBook, MySpace, or a dozen other social networking sites.\n\nMeanwhile, entertainment technology keeps evolving. The sites and games get more and more intricate, fun, time-intensive, and immersive. Rational, normal people have a harder and harder time putting these things down and doing other things. That's by evolutionary design: the most addictive online content site wins. If it doesn't keep you attentive even when you should be doing something else, no matter how important the other thing is, another site will come along that will be able to.\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Very young brothers playing video games](2019-04-brothers-playing-video-games)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n    In 2019 multiple studies are showing that prolonged screen time has a damaging -- and perhaps permanent -- effect on developing brains\n</figcaption>\n</figure> \n\n\n**Technology is Heroin.**\n\nIt's still very early. We're still in the phase of expecting some even better technology to come along and save us from this problem. Programmers are creating \"no procrastinate\" options for their web sites in order to help users not spend so much time there. Programs are being written to track online time to show users where they are spending all of their energy. The new addictive program will eliminate the ills of the old one.\n\nMeanwhile, people get fatter and fatter, unable to get around or physically accomplish normal chores from a 100 years ago. Intelligence is going down as fewer and fewer books are being read (news flash: the printed book industry is on the way out unless this trend stops), and social organizations like churches and civic clubs see fewer and fewer members attend their meetings. The skills that are increasing? Reflex time. Ability to solve abstract, short-timespan problems. Basically the skills we need to interact with our entertainment. More and more, Indians and Chinese -- people coming from cultures who have been shut out of the technical world until recently -- are writing software for hardcore western appetites to consume. \n\nNow that sight and sound are covered, new internet appliances promise to offer touch, smell. Locomotion is old hat. Eventually there will be a direct brain interface. There has to be: competitors will become so strong that only by direct brain stimulation will technology be able to continue to evolve.\n\nPeople say that this is a good thing -- as technology evolves we will become trans-human: we will integrate in with machines and be able to process and work a thousand times faster than before.\n\nThis may be true. But if so, it would be a side-effect, not a direct result. That's like saying it'd be great to get hit by a train because you've always wanted a train ride. The driver here is the competition between various pieces of technology and brain-time. Whatever controls the most brain-time wins out evolutionarily over any other product, not matter how valuable it might be. World of Warcraft beats Wikipedia hands down. That driver will continue. It's foolish and pollyannish to think that somehow it'll all work out. Unless the conditions for the evolving threat cease, it will keep growing and adapting, no matter how much better, stronger, and faster we are.\n\nIt's all happening slowly, much slower than it did with heroin. We don't have the time-intensive life we once did. Heroin was a simple substance that had immediate, clear effects; this is a process of adaptation and survival that is taking generations. Heroin hit you in the face and still it took 50 years for us to figure it out. This is slowly creeping up our leg and strangling our minds, our souls, millimeter by millimeter, year by year. By the time we figure this one out, it might be too late.\n\nNo matter what, it will once again change our definition of what it means to be human.\n\nTags:\n* future\n* philosophy\n* technology\n\n96 Comments (not reproduced here)\n\n![](DanielsSignature)\n\n\n* [Follow the author Twitter](https://twitter.com/danielbmarkham)\n* [EMail the author](mailto:Daniel@DanielBMarkham.com)","Approved":true,"Categories":["recQbvNMbYGcFSc8z","recnSIAaEwa0CbWuE"],"Tags":["reca8DqcFBPyWFHih","rec8Q7Sn8p6DNLNKJ","recUYaxsODSxiFiDo","rec7gGYpwgdJ5E76y","recIPGRFebYI7QFwM","receRQaf4IK9F57ip","rec2QDCvagB9knYdM"],"StartDate":"2019-04-09T07:00:00.000Z","Blog":["recCGKQBlTWHqrGCu"],"Questions":["recbHiSxqyBiNiuDv","recMMoTy278CTdyBI"],"TemplateFile":"Entry1.html"},"createdTime":"2019-04-09T17:37:11.000Z"},{"id":"recak5uVmYH6H7cLV","fields":{"ID":44,"Authors":["recPwgCd6QGPvd5Fg"],"Title":"Setting up your own AWS - VS Code build","Content":"## How do you dive into a completely new field of tech?\n\nI know programming. I know servers. AWS? Not so much. I know the general idea of what it does -- hell, the dang thing does most anything. I also have a professional need to become much more familiar with how it all hangs together. I've been setting up servers and VMs on remote machines ever since the first abacus, but AWS is an entirely new animal.\n\nLet's go figure out how it works.\n\n*This is the third in a three-part series. You can find the others in the posts entitled [\"Minimum Blogging Platform\"](http://tiny-giant-books.com/Entry2.html?EntryId=recXmHgxSFwTTZy1t) and [\"Minimalist full-featured blogging with Vue, AirTable, Bootstrap, Markdown\"](http://tiny-giant-books.com/Entry2.html?EntryId=rec7eixYJR006U879)*\n\n<div>\n<div class=\"embed-responsive embed-responsive-16by9\">\n<iframe class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/zktPdONoooU?rel=0\" allowfullscreen></iframe>\n</div>\n<p class=\"figure-caption text-center text-muted\">\nGet the free tour. Please, no pictures.\n</p>\n</div>\n\n```\n<lecture>\n```\n\nThe main thing here is **goal-directed learning**. You may have come across similar concepts if you've read anything about the Montessori Method of Education or Un-Schooling. Everything we touch in tech is complex, complicated. The entire IT training industry is based around picking all of the things we use in our work apart, selecting one, and then based on the technology and version training people in-depth on that particular thing.\n\nYou can study one of these areas as much as you want, but until you start actually applying knowledge in service to a larger, external goal you're not going to learn what you need to know. After all, nobody gives you a job that just consists of passing a test. [Hopefully!] More importantly, until you start using your skills in service of external goals, you won't be able to tell what's important to learn and what's just wasting your time in endless minutiae. You have no context.\n\nEvery good value discovery team consists of people who can work in all areas as-needed. Sure, people naturally gravitate towards one area or the other, and there's nothing wrong with sticking with a tech you love for a while. But unless you are regularly externally-validating what you're learning against real-world problems, you very quickly become part of the problem and not part of the solution. This is critical to know and deeply grok if you care about your career.\n\nTech is not a push-based system, with you learning the stuff you love and then insisting the world conform to you. You get pulled. Tech's a pull system. There are two types of things that can pull you. You can either try to figure out what the cool kids are doing and learn how to please them -- or you can use real world business problems to tell you what's important or not. When I was younger I did the cool kid stuff. This was much fun. Got to be the rock star and the smartest guy in the room many times. The problem was there were a lot more cool kids than I had brain cells -- and my brain cells kept dying off while the cool kids kept multiplying. So now I go the other way.\n\n(Even then, however, I found that without projects that were meaningful to me, I had a difficult time anything learning in-depth.)\n\n```\n </lecture>\n```\n\n\n<figure>\n<pre style=\"font-family:Consolas;font-size:13px;color:black;background:white;\"><span style=\"color:blue;\">let</span>&nbsp;processEvent&nbsp;(event:string)&nbsp;(context:&nbsp;ILambdaContext)&nbsp;=&nbsp;async&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">let</span>&nbsp;bucket=context.ClientContext.Environment.Item(<span style=\"color:#a31515;\">&quot;S3_BUCKET&quot;</span>)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">let</span>&nbsp;filename=<span style=\"color:#a31515;\">&quot;foobar.txt&quot;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;<span style=\"color:#a31515;\">&quot;put&nbsp;%s/%s&quot;</span>&nbsp;&nbsp;bucket&nbsp;filename\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">let</span>&nbsp;hours=context.ClientContext.Environment.Item(<span style=\"color:#a31515;\">&quot;CACHE_HOURS&quot;</span>)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">let</span>&nbsp;expiresDate=System.DateTime.Now.AddHours(Double.Parse(hours))\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">let</span>&nbsp;req=Model.PutObjectRequest(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BucketName=bucket,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key=filename,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContentBody=<span style=\"color:#a31515;\">&quot;I&nbsp;exist&quot;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">let!</span>&nbsp;resp=s3Client.PutObjectAsync(req)&nbsp;|&gt;&nbsp;Async.AwaitTask\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;resp\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processEvent&nbsp;event&nbsp;context\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Async.RunSynchronously</pre>\n<caption>Hey! That looks a lot like F#! I like F#!</caption>\n</figure>\n\n### The main thing about the main thing\n\nIf you're new to all of this -- servers, DevOps, the cloud, and scaling past a simple toy project, here's the key thing to know: *everything is code*. Your program, how's it's tested, where it goes after it's built, the servers, the website, the SSL certificates. Everything. You may have heard this in various forums, but it's the first and most important lesson to learn.\n\nWelcome to The Matrix.\n\nThis leads us to what I call \"The Video Game Problem\". I first ran into it back when the first GUI databases came out. People would buy a computer, take it to their business, and wow! There was a little video-game like toy they could use to create databases! Woo hoo! So create databases they did. They created a ton of databases. Point, click, there's a database. They loved this thing! What could go wrong?\n\nMost were disasters, of course, since database creation and management is something you gotta learn, not something you poke at on a screen until it works -- *at least if you're going to keep poking at it*. And so lots of consultants made lots of money cleaning up databases.\n\nAs far as I know, the pattern kept repeating over and over again, just with cooler UIs and more complicated systems. Enterprise databases came out. Developers would go to the UI for the database and honk around with it until their program worked. Yay! Then they'd put up a sign: \"Don't touch this server!\"\n\nThey made much bigger and uglier messes. Consultant made lots of money cleaning them up. Same with server configs, build pipelines, tiered architectures, you name it. One bunch of developers kept making more and more complicated things -- usually by taking a previously-existing layer of complicated things adding stuff on top to make it simpler. These layers and tools had super-cool and awesome UIs and other developers loved them. Then another bunch of developers kept making messes with the things the first developers built. Money was spent, businesses and projects failed, and consultants came in and cleaned-up (In more ways than one.)\n\nDon't get me wrong. There's nothing wrong with hacking your way through getting something running. This essay is all about that! But you gotta know the major failure modes, the **things we must not do**. So the first rule in learning your way through a project is to learn about the major and most common failure modes and how to avoid them. With any tech there's usually only a dozen or so big ones. You can/should pick up the rest as you go along. The first rule in moving to the cloud in a big and non-trivial way is that everything has to end up in code. Play if you like with the UI to learn, but ***never  ever deliver something of value that you made work by playing with a UI somewhere***. If it's valuable, it's version-controlled code.\n\nThere are other lessons we'll cover as we go along. There's also several \"gotchas\" and tips in the video -- things I ran across coming in cold. Here are a few that didn't make the video:\n\n* Be prepared for \"real\" DevOps, not the \"I bought it at WalMart\" stuff you might find in your average large corporation. If you can make it work from scratch, you can make it work using any tool they give you, so that's where we start.\n* For you coders, this is not as hard as learning a new programming language. Of rather, in some ways it's easier, in other ways harder. The issue here is not complexity, but tons of little stuff all over the place. Many times I found myself knowing I had to do something, knowing there was a way to do it -- but at a loss as to where the right tool or flag was. A good AWS Cloud Architecture course can help here much in the same way as taking one of those bus tours of a new city can help you decide where you'd like to explore. It helped me.\n* Some things happen right away. Some things take minutes to run. Some logs go to one place. Some logs go to another place. It's not like a local PC or an SSH-ing into a server. You click a button, things happen. Somewhere. Eventually. But you gotta figure out where and when.\n* Don't be afraid to play. I've never been afraid of breaking the computer, but after hearing horror stories of huge cloud bills, I was afraid of accidentally spending a ton of money. There are ways to prevent this.\n* I told you not to rely on the UI to deliver, but I found it quite useful to use to tweak things. It simply takes too long for a full build of anything non-trivial (Insert discussion here around ways to speed things up). So I'd build, then tweak using the AWS web UI, then once I knew I had changes I liked I'd put them back in the code. Every 2 or 3 changes, I'd drop it all, check it in, and rebuild. This got old in a hurry, but it was faster than trying to make every small change in code and then waiting 2 minutes for the stack to stand up. Slow build-compile-test-deploy times will destroy your soul and make you question your life choices. Avoid them at any cost.\n* There are multiple ways to do anything, therefore you're going to need to grow your own spidey-sense to find the simplest way to get done what you need. Otherwise -> mess.\n* I would not want to come at this cold, with no admin, ops, or development experience. In fact, I'm not sure it's possible. (This has profound industry implications.)\n* When you're setting up your own build stack like I am, what things do you want to automate? This was an easy question when the goal was simply to test, code, the check-in to the pipeline. Then the pipeline did things. Now, however, I can use VS Code to control the entire AWS stack. I have the power. I am the master. So how do I want to group my automation tasks? My first stab:\n    - Build Local\n    - Test Local\n    - Deploy Code\n    - Deploy Blue Cloud\n    - Test Blue Cloud\n    - Swap Blue and Green\n\nThis seems like a good stopping point. I'd like to get more into the code, but it's vastly more important to get your head right before you start trying to get the code right. It'll be fun using this setup to take AWS, F#, VS Code, and dotnet for a spin! We've already got a good start. Can't wait for my next project. For more of the technical details, watch the video and check out the source code. I'm also always happy to chat about nerdy stuff.\n\nThanks for hanging out!\n\n\n---\n\n* You can find the source code for all of this at the [THX-1138 GitHub repo](https://github.com/DanielBMarkham/thx1138).\n\n* My goal is to blog about all levels of successful product development, from coding and devops, like in this essay, through team and program activities, ending up with organization level hacking using things like Lean Startup and enterprise governance/tooling. I think there are several core concepts that you can apply across the entire range of IT work, from junior developer to division head. If you'd like to join me in this journey, I'd like to have you along. You should buy the book. It all starts there. [Ino-Ops: Team Level](https://leanpub.com/info-ops?ref=tgb)\n\n![](DanielsSignature)\n","Excerpt":"I know programming. I know servers. AWS? Not so much. I know the general idea of what it does – hell, the dang thing does most anything. I also have a professional need to become much more familiar with how it all hangs together. I’ve been setting up servers and VMs on remote machines ever since the first abacus, but AWS is an entirely new animal.\n\nLet’s go figure out how it works.","Approved":true,"Categories":["recD6fV22IR0LSVdB"],"Tags":["recIPGRFebYI7QFwM","rec8Q7Sn8p6DNLNKJ","recSfRhJdArFwzoIa"],"StartDate":"2019-03-24T15:00:00.000Z","Blog":["recCGKQBlTWHqrGCu"],"TemplateFile":"Entry1.html"},"createdTime":"2019-03-24T19:04:45.000Z"},{"id":"recj67HoP8cKW5Eso","fields":{"ID":43,"Authors":["recPwgCd6QGPvd5Fg"],"Title":"Good Enough Programming","Content":"<div><blockquote style=\"margin-left:5rem;margin-right:5rem;margin-top1.5rem;margin-bottom:1.5rem;font-style: italic; font-size:110%\">What is the appropriate driver that causes you to open up code for the sole purpose of making it better? My answer: it's always a failure, but failures happen. You should prioritize not opening the code up for maintenance as much as you prioritize delivering value</blockquote></div>\n\nI bought a new car recently. I use it to go to the gym and on hiking trips.\n\nIf one day I decided to go to the donut shop and liquor store instead, I wouldn't expect an automotive engineer to show up from Tesla to redesign and program my car. I wouldn't expect to change anything at all. The concept of how the car is constructed and where I want to go are completely separate things. They should stay that way.\n\nOne phrase that represents that concept is \"separation of concerns\". There's a better phrase, however, that we use in programming. It's when you look at code and note that it has the appropriate \"coupling and cohesion\". Coupling is how dependent things are on one another. Cohesion are how stuck together things are.\n\nInside my car, though, I'd expect the engine and the wheels to be highly coupled. No point in having one without the other and they're made to work together. I wouldn't expect them to be highly cohesive. I should be able to put new wheels on the car or change out the engine without it having anything to do with the other pieces. Things that become too tightly-coupled can also end up highly-cohesive.\n\nWhile coupling and cohesion are programming terms, they also exist in the real world, in things like cars or how we approach our work. A great part of the problem we face as technology folks is that software has eaten the world and nobody is thinking about what that means in terms of coupling and cohesion at a business level, i.e., how we look at our goals. Instead we think in specialty areas, in silos.\n\n***Truly getting rid of silos means balancing each silo's definition of perfection.***\n\nLet's say that last week you wrote an app that people love and use everyday. What are the reasons you would touch it again? Why would you go back in and change anything?\n\nThere are only three:\n\n1. You want to add new things so that people like it more in the future\n2. You want to fix broken things, things people currently do not like\n3. You want to make your work easier. It looks difficult to maintain if one day you have to go back to fix or add things\n\nThat's it.\n\nOption 3 is odd. Let's explore it. It's basically saying that the people using your app have no complaints. They like it fine. You are the person that doesn't like it. Of course, there are many good reasons not to like a piece of code. It's unwieldy, hard-to-understand, or brittle. It uses the old version of WheedleKnob that nobody else is using. It doesn't have good unit tests. It breaks some of the rules of Clean Code. You're sure you're going to have to add something else in there and now is the time to make it easy to do so.\n\nYour code has a *smell*. A code smell.\n\nAll three reasons to change your app are good ones, but note: the first two items on the list are external factors. There's something happening outside of your control that causes you to go into the codebase again. The third item? It's all you. There's something happening inside your head to cause you to go into the code. What you want you code to look like and what you see in your IDE doesn't match up. In the first two, there's coupling between the people who use our app and what we're doing.\n\nWhere's the coupling in the third reason? How do you know when to start or when you're done changing your app to make it perfect? For some folks, there's a little bit of cleanup and refactoring and they're happy. For other folks, they spend years or decades and still have a huge list of things that still needs fixing.\n\nWithout further context, which of these two people are the better programmer? If you can tell, you're better at this than I am. It is true that as an industry we've generally decided on a lot of things that are part of the discipline of being a professional programmer, things like test-driven design for OO projects. \n\nIt's also true that there's variability for each discipline, like programming, there's personal taste, there's team and corporate standards, there's new versions, there's idiomatic standards, and there's an infinitely-expanding list of disciplines that any serious effort touches.\n\nAdd to that crappy code, and for most teams they don't ever touch anything. They're too scared -- at least until they absolutely have to, then they end up breaking stuff. That's a very bad situation that things like TDD aim to solve. But there's a difference between being afraid to touch anything and not having criteria for when to start or how much to do. You should never be afraid to touch or refactor your code. That doesn't mean you should be horsing around with it everyday simply because a new library version came out, either.\n\nIf everybody's happy but you, what does it take to make you happy?\n\nNo matter how well you code a system, you can always do better. We're not just talking about programming. If it were one discipline, the answer would be some kind of team coding standards, which are a great idea. But that's not the real world. We do not live and work in cohesive teams all using one or two technologies where we have established common coding standards. Any modern true cross-functional team involves dozens of technologies. \n\nThere's databases, servers, UX, release plans, compliance. The technology industry has hundreds of disciplines, with dozens more popping up every month. Each of these disciplines contain teachers, conferences, certifications and a community where the thrust is always the same: *more and more precision around what makes a great X*. Do X perfectly, and if everybody else does A,B,C,D and so forth? It'll all come out okay. If not? You should have done X better! Have you read the latest book?\n\nIf you don't like your exception handling strategy, should you start refactoring? What if the DBA doesn't like the field names? Or the security guy tells you that you need to update to TLS 2.0?\n\nIf you don't see the problem here then you've never worked at a large corporation where it requires 30 people to change a log-in form (Been there, got the t-shirt). You've never started a personal project and then given up on it after a few months because you seemed to have gotten mired down in all the tiny details that need to be done. You've never mastered seven or eight items in a tech stack only to see them all change to new versions while you were learning.\n\nThis is a common problem in programming and in technology in general: places where there's no feedback loop so there's no real way of knowing when enough is enough. Or how much is too much. When you pick up a dozen pieces to solve a problem, if you're not careful you'll have two dozen pieces before you put them back down again. There's no value being created, only more and more pieces to master. \n\nWe have met the enemy and he is us.\n\nReason 3 in our list, making our work easier, is tightly-coupled to our personal tastes and to a continuously changing array of technologies, disciplines, and versions. Not just tightly-coupled, they're tightly-cohesive. They're all stuck together. On any given day, there's really no reason **not** to open up the codebase. So here we are, one bunch too afraid to touch anything and the other bunch never having a good reason not to.\n\nInstead of trying to figure out how much is too much, let's reduce scope. Let's start on the other end of the spectrum. Let's assume numbers 1 and 2 on our list are okay, that is, you've written something that people find value in, there's no more to add by way of new features and there's nothing about it that they don't like. Let's talk about how we know we should start.\n\nIf there's no new features to add and nothing the users want fixing, why would you ever open the codebase up to poke around in it? You wouldn't. It's not perfect. Of course not. It's good enough.\n\nThis leads us to our definition of Good Enough Programming which any professional serious about delivering solutions should know: **Implementing technology has two primary goals: it delivers value and you can walk away from it. To fail at either of these two goals isn't good enough.** Nobody comes to my house and rebuilds my 15-year-old iPod. I pick it up. I push a button. It plays songs. It's good enough. That's the minimum acceptable goal.\n\nHaving products that are good enough allow me to take them for granted and use them to advance my life and become a better person. Over time, ones that aren't complicate my life and hurt me, even if they mean well and I like the features.\n\nThe same goes for you. Even if you deliver bug-free code for users who love it, if you have to keep opening the codebase/configuration for whatever reasons, your costs (and risks) are effectively infinite. It may be perfect, but it's not good enough.\n\nWe are left with a conclusion that many might find uncomfortable. Although it's perfectly fine to open up code to make it \"better\", and this is a normal thing that happens all of the time, **it's also a failure of some other part of our value creation and delivery strategy. It should be always be considered as such**.\n\nIt's important to understand that I'm not talking about the **discovery of business value**, only the **creation and delivery of the technology**. If you want to be a good programmer, the first thing you have to know is when to start and stop programming. Somehow because business conditions constantly change, we've gotten it into our collective heads that technology must constantly change also. This is a false assumption and a vast over-statement of reality.\n\nSometimes people might want to use their cars to do new things, like go to the donut shop. So from time-to-time we should look at our cars to make sure they still do things our customers want. That doesn't mean we go out and start taking people's existing cars apart in their garages to install donut-holders.\n\nWhile it is a generic, overall truth that the business environment is constantly-changing and we must change quickly to adjust to it, that doesn't have to be true for your particular application. If it is, your coupling is too tight. You wouldn't accept that in a method, you wouldn't accept it in a car, and you shouldn't accept it in the way you use technology to make stuff people want. It's not good enough.\n\nGood Enough Programming means equally prioritizing user value with the ability never to touch the code or configuration again.\n\nNow we can talk about moving as fast as we need to when conditions change. How we can be super-freaking ninja rockstar kung-fu technology lord masters of space and time. We can talk about being perfect. We should always strive for perfection. But that's never going to fly unless we start out by just being good enough.\n\n\n![](DanielsSignature)\n","Excerpt":"What is the appropriate driver that causes you to open up code for the sole purpose of making it better? My answer: it's always a failure, but failures happen. You should prioritize not doing this as much as you prioritize delivering value","Approved":true,"Categories":["recD6fV22IR0LSVdB"],"Tags":["recIPGRFebYI7QFwM","rec8Q7Sn8p6DNLNKJ","recSfRhJdArFwzoIa"],"StartDate":"2019-03-10T08:00:00.000Z","Blog":["recCGKQBlTWHqrGCu"],"TemplateFile":"Entry1.html"},"createdTime":"2019-03-11T08:49:25.000Z"},{"id":"recDglRyfN9NrlTVR","fields":{"ID":37,"Authors":["recPwgCd6QGPvd5Fg"],"Title":"Product Management Bullshit Eliminator","Excerpt":"In beta","Approved":true,"Categories":["recD6fV22IR0LSVdB","recQbvNMbYGcFSc8z"],"Tags":["recLfkSmV5wJby8YI","recrv9vV7H2K5WayC"],"StartDate":"2019-01-25T18:00:00.000Z","Blog":["recCGKQBlTWHqrGCu"],"Questions":["recYUu7t6kgQ63oZx","recbmGBMrftbwj0Va"],"AdminNotes":"Same","TemplateFile":"Entry1.html"},"createdTime":"2019-01-22T02:41:26.000Z"},{"id":"rec7eixYJR006U879","fields":{"ID":30,"Authors":["recPwgCd6QGPvd5Fg"],"Title":"Minimalist full-featured blogging with Vue, AirTable, Bootstrap, Markdown","Content":"## The Setup\n\n**Mission**: Take [a small bit of code I created last month](http://tiny-giant-books.com/Entry2.html?EntryId=recXmHgxSFwTTZy1t) to show how simple fully-scalable server-free blogging could be. Make it into something more like what you'd sell as a product: a component system, skins, lots of online help available.\n\n**Obstacles**: Use a code budget. Easily be able to provide anything any other blogging system can do. Work without either a server or Internet connectivity. Spend no more than a few days developing in my spare time. Cost nothing to operate.\n\n**Justification**: Because it's one thing to show that something can be done. It's something else to actually do it. Because the best way to learn tech is to play with it. Because observing how programmers program tells us something deep about the way humans solve problems.\n\nBecause it'll be fun!\n\n**Tech**: I chose AirTable, AWS, Bootstrap, and Vue.js. I also chose to do the work using VS Code.\n\nI had been away from web programming for about a year or so coding in F# and tech coaching. I was interested in how all the new stuff would play together.\n\n<div>\n<div class=\"embed-responsive embed-responsive-16by9\">\n<iframe class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/oAxt7VYCf6s?rel=0\" allowfullscreen></iframe>\n</div>\n<p class=\"figure-caption text-center text-muted\">\nLet me show you how this thing is put together\n</p>\n</div>\n\n\n## The Journey\n\n[Good technical architecture always comes from proving out structure bit-by-bit as we take our values and slam head-first into the things that are absolutely required](https://wiki.info-ops.org/index.php/Main_Page#Information_Tagging). I've expressed my values above, and as an experienced database designer and blogger, I *think* I know what's required for those values, but even in a highly-controlled, tightly-scoped project like this, [I have to insist on ignorance](https://twitter.com/danielbmarkham/status/995299203231371265). So I took the POC last month and added some entries, seeing if the database structure I had set up on AirTable could to handle what I wanted to do.\n\nIt could not.\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![Alternate entry list created for mobile devices](2019-01-n23shot)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n</figcaption>\n</figure>\n\nI didn't miss anything major, but I did add, remove, and rename fields. I set up a second blog to run on the same database. On this one I would just copy and paste stuff in (in order to simulate volume) because one example is never enough. Two examples suck, but it's better than one.\n\nThat done, I started organizing my code and files as if I were building to sell or re-use something. That meant components, some standardization, and a bit of compatibility checking.\n\nAs I organized my files, I added and changed *even more* database structure. For one thing, I decided that all tables would have certain fields: ID, Blogs, TemplateFile, AdminNotes, Approved, and StartDate. Every table but Entries would also have a PublicDescriptionShort and PublicDescriptionLong. (Entries covers that with Excerpt and Content)\n\nA standard set of fields allowed me to consolidate my Javascript code. My tables ended up looking like this:\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![](2019-ABv2DB-center)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n<p>It's a star! (It's also a DAG)</p>\n</figcaption>\n</figure>\n\nI picked the most heavily-used functionality, showing the list of blog entries, and I made a second page to do it in a completely different way. It had voting, popups, a candy-bar kinda feel. I decided for a twist I wanted to group entries also by the questions they addressed. How well could what I built handle change?\n\nOnce that page was built, I copied both pages out into separate components to display the entry list. I factored a bit -- enough to start exercising my javascript data library. Data flows like so: AirTable database->live/chron json access->javascript data library->UI goodness with Vue->screen. Evolution happens along the lines of data flow. So the database gets exercised and tested the hardest, because whatever you do involves the database. It gets nailed first. Then the data movement code. Then the javascript data library, and so on. Eventually I ended up with a Vue base component too. I added layers only when I needed them.\n\nMy page/component dependencies ended up looking like this:\n\n<figure class=\"figure\">\n<div class=\"embed-responsive\">\n\n![](2019-ABc2UI-center)\n\n</div>\n<figcaption class=\"figure-caption text-center text-muted\">\n<p>As it is used more, the JS code starts organizing itself</p>\n</figcaption>\n</figure>\n\nI wasn't too overly-concerned about clean code, which is an extremely-odd thing for me to say, being a tech coach. This is a FP-oriented, UI-only app. I haven't built a test harness yet. Both of those things impact in what order you set up testing and how you perform it.\n\nIn OO you've always got a strategy to put stuff somewhere. I was using more of an FP approach, however, and until I know more about the functionality the app needs it is impossible to optimize the structure of the code that provides that functionality.\n\nI made the decision early on that there would be one Javascript \"thing\" that would know all about the blog and what was in it. There would be another \"thing\" that knew all about how I wanted my blog to look on a web page. You can call that doc-view, or MV, or roasted peanuts. It was the logical thing to do. Once that split was made, further splits became easier and easier as they were needed.\n\n## The Observations\n\n**Data juggling wasn't the issue I thought it might be**. I was initially concerned about ending up rebuilding a Relational Integrity engine, only in Javascript. Shouldn't I use a library?\n\nThat didn't pan out for a lot of reasons. The data is read-only. There are no transactions. What happened was that I ran into a data problem that had much more to do with Javascript than RI. Being loosely-bound, Javascript will run with most anything -- until it doesn't. If AirTable didn't have data for a field, that field simply didn't exist on the front-end. It was undefined.\n\nSo I ended up double-checking for undefined everywhere in my JS database engine, which is a good thing. If I get bad/empty data, I want to keep on trucking along. We should always write error-free code -- which doesn't always mean what you think it might! The code should never terminate in an unanticipated manner. (Or just never terminate and always finish in some acceptable fashion.)\n\n**I like how the Javascript ecosystem is evolving**. Functional stuff like maps, arrow functions, filters, and such? Very nice. A real module system? Most excellent. Template literals rock. I didn't get to try default parameters, but they also looked most aweseome.\n\nIn fact, I don't think I really needed Vue at all -- but that's a project for another day.\n\nHaving given all that praise, please, please, please folks! Attention people who work on Javascript-related standards bodies. Pick a point and stop. I beg of you. Don't become C++. I don't need Haskell or ML in my JS. If Javascript tries to do everything well, it ends up doing nothing well.\n\n**You can easily make a nice mess even with a very small amount of code and a minimalist philosophy**. Once I reached the limits of my code budget, I started cleaning up. What I thought was going to be an hour or two turned into a day or two. (I was watching TV while doing it, so perhaps it'd be quicker at the office, but it still felt like a lot longer time than I anticipated) CSS, especially, can end up impacting stuff all over the place. The JS code got messy but was easy enough to sort out and optimize. CSS is another animal entirely. Yet we still must meet our code budget.\n\n**I had a hard time stopping**. You reach a point where your project does mostly everything you want it to -- so you keep adding stuff and tweaking. Dang, this was fun! Especially since it was, well, *my stuff*. These weren't just essays, they were great works of art! They need a good engine!\n\nThe problem here is called bike-shedding. Bike shedding is when a decision needs to be made but the results of that decision have no discernible impact. Do you want me to pain the bikeshed blue or green? Where do I put this piano? Which hat should I wear today?\n\nOddly enough, decisions with little or zero impact can be some of the toughest to make, especially in a committee setting, but it happens even when you are working alone. I started confusing *how I wanted the blog and the code working the blog to look aesthetically* with *how the insides of the code needed to look to get the job done*.\n\nThis solved itself as fairly soon most changes started coming down to either the components file or the css, telling me that the data library was mostly done, no matter what it looked like. As my coding moved from \"this is broken\" to \"that menu needs to be centered\", I had to be sure I was still programming and not engaged in some weird nerd modern art project.\n\n## The stuff I wished I had done better\n\n- I may have lost track of my closures. Not sure. We'll see.\n- I lost track of the new rules for variable/method visibility from inside object/modules. Had to look that up. Probably got bits wrong.\n- Got into responsive design by accident trying to align and standardize CSS tags inside components. Bailed out. Realized if I wasn't careful I'd end up creating something close to an \"artisanal website\" -- lots to do there. That kind of work was not relevant here aside from giving me a close guess on how the tags should nest\n- I wanted to use arrow functions more instead of anonymous functions the way I initially coded. It's a nit --- but it bugs me.\n\n## The code\n\nHere's what you need for a web page that acts as a template for blog stuff. You put all the goodness inside a Vue component:\n\n<pre style=\"font-family:Consolas;font-size:13px;color:black;background:white;\"><span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">html</span>&nbsp;<span style=\"color:red;\">lang</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;en&quot;</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">head</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">meta</span>&nbsp;<span style=\"color:red;\">charset</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;utf-8&quot;</span>&nbsp;<span style=\"color:blue;\">/&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">meta</span>&nbsp;<span style=\"color:red;\">name</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;viewport&quot;</span>&nbsp;<span style=\"color:red;\">content</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;width=device-width,&nbsp;initial-scale=1,&nbsp;shrink-to-fit=no&quot;</span><span style=\"color:blue;\">/&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">title</span><span style=\"color:blue;\">&gt;</span>Home&nbsp;Page<span style=\"color:blue;\">&lt;/</span><span style=\"color:maroon;\">title</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">link</span>&nbsp;<span style=\"color:red;\">rel</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;stylesheet&quot;</span>&nbsp;<span style=\"color:red;\">href</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;css/fa-svg-with-js.css&quot;</span>&nbsp;<span style=\"color:blue;\">/&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">link</span>&nbsp;<span style=\"color:red;\">rel</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;stylesheet&quot;</span>&nbsp;<span style=\"color:red;\">href</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;library.css&quot;</span>&nbsp;<span style=\"color:blue;\">/&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">link</span>&nbsp;<span style=\"color:red;\">rel</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;stylesheet&quot;</span>&nbsp;<span style=\"color:red;\">href</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;main.css&quot;</span>&nbsp;<span style=\"color:blue;\">/&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">script</span>&nbsp;<span style=\"color:red;\">src</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;js/fontawesome-all.min.js&quot;</span><span style=\"color:blue;\">&gt;&lt;/</span><span style=\"color:maroon;\">script</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">script</span>&nbsp;<span style=\"color:red;\">src</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;library.js&quot;</span><span style=\"color:blue;\">&gt;&lt;/</span><span style=\"color:maroon;\">script</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">script</span>&nbsp;<span style=\"color:red;\">type</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;module&quot;</span>&nbsp;<span style=\"color:red;\">src</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;airblog.js&quot;</span><span style=\"color:blue;\">&gt;&lt;/</span><span style=\"color:maroon;\">script</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">script</span>&nbsp;<span style=\"color:red;\">src</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;main.js&quot;</span><span style=\"color:blue;\">&gt;&lt;/</span><span style=\"color:maroon;\">script</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;<span style=\"color:blue;\">&lt;/</span><span style=\"color:maroon;\">head</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">body</span>&nbsp;<span style=\"color:red;\">class</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;vueComponent&quot;</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">div</span>&nbsp;<span style=\"color:red;\">class</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;container&quot;</span>&nbsp;<span style=\"color:red;\">id</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;mainApp&quot;</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">div</span>&nbsp;<span style=\"color:red;\">id</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;holder&quot;</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">div</span>&nbsp;<span style=\"color:red;\">class</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;vueComponent&quot;</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">blog-navigation-header-menu</span>&nbsp;<span style=\"color:red;\">:atmyblog</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;atMyBlog&quot;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:red;\">attags</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;atTags&quot;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:red;\">atquestions</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;atQuestions&quot;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:red;\">:atcategories</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;atCategories&quot;</span><span style=\"color:blue;\">&gt;</span>\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;/</span><span style=\"color:maroon;\">blog-navigation-header-menu</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;/</span><span style=\"color:maroon;\">div</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:darkgreen;\">&lt;!--&nbsp;Fairly&nbsp;simple&nbsp;list&nbsp;of&nbsp;blog&nbsp;entries&nbsp;--&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">main</span>&nbsp;<span style=\"color:red;\">class</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;main&quot;</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">div</span>&nbsp;<span style=\"color:red;\">class</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;vueComponent&quot;</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">entry-list-plain-component</span>&nbsp;<span style=\"color:red;\">:entries</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;atEntries.records&quot;</span><span style=\"color:blue;\">&gt;&lt;/</span><span style=\"color:maroon;\">entry-list-plain-component</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;/</span><span style=\"color:maroon;\">div</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;/</span><span style=\"color:maroon;\">main</span><span style=\"color:blue;\">&gt;</span>\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:darkgreen;\">&lt;!--&nbsp;Standard&nbsp;branded&nbsp;footer&nbsp;--&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">div</span>&nbsp;<span style=\"color:red;\">class</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;vueComponent&quot;</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">plain-footer</span>&nbsp;<span style=\"color:red;\">:blog</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;atMyBlog&quot;</span><span style=\"color:blue;\">&gt;&lt;/</span><span style=\"color:maroon;\">plain-footer</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;/</span><span style=\"color:maroon;\">div</span><span style=\"color:blue;\">&gt;</span>\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:darkgreen;\">&lt;!--&nbsp;Modal&nbsp;About&nbsp;the&nbsp;blog&nbsp;--&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">div</span>&nbsp;<span style=\"color:red;\">class</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;vueComponent&quot;</span>&nbsp;<span style=\"color:red;\">v-cloak</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">modal-about-the-blog</span>&nbsp;<span style=\"color:red;\">:atmyblog</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;atMyBlog&quot;</span><span style=\"color:blue;\">&gt;&lt;/</span><span style=\"color:maroon;\">modal-about-the-blog</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;/</span><span style=\"color:maroon;\">div</span><span style=\"color:blue;\">&gt;</span>\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:darkgreen;\">&lt;!--&nbsp;Modal&nbsp;Read&nbsp;Article&nbsp;--&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">div</span>&nbsp;<span style=\"color:red;\">class</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;=vueComponent&quot;</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;</span><span style=\"color:maroon;\">modal-read-article</span>&nbsp;<span style=\"color:red;\">:atmyBlog</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;atMyBlog&quot;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:red;\">:atmyentry</span><span style=\"color:blue;\">=</span><span style=\"color:blue;\">&quot;atMyEntry&quot;</span><span style=\"color:blue;\">&gt;&lt;/</span><span style=\"color:maroon;\">modal-read-article</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;/</span><span style=\"color:maroon;\">div</span><span style=\"color:blue;\">&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;/</span><span style=\"color:maroon;\">div</span><span style=\"color:blue;\">&gt;</span>&nbsp;<span style=\"color:darkgreen;\">&lt;!--&nbsp;main&nbsp;Vue&nbsp;app&nbsp;!--&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">&lt;/</span><span style=\"color:maroon;\">div</span><span style=\"color:blue;\">&gt;</span>&nbsp;<span style=\"color:darkgreen;\">&lt;!--&nbsp;container&nbsp;!--&gt;</span>\n&nbsp;&nbsp;<span style=\"color:blue;\">&lt;/</span><span style=\"color:maroon;\">body</span><span style=\"color:blue;\">&gt;</span>\n<span style=\"color:blue;\">&lt;/</span><span style=\"color:maroon;\">html</span><span style=\"color:blue;\">&gt;</span></pre>\n\nWell heck, that's not much code. Where's the real code at? What's in these components? Let's dive down further, take a look at the component that displays the content of the blog entry -- the one you're using right now to read this.\n\n<pre style=\"font-family:Consolas;font-size:13px;color:black;background:white;\"><span style=\"color:blue;\">var</span>&nbsp;EntryDetailFullComponent&nbsp;=&nbsp;{\n&nbsp;&nbsp;template:&nbsp;<span style=\"color:#a31515;\">`\n&nbsp;&nbsp;&lt;div&nbsp;class=&quot;atEntryDetailFullComponent&nbsp;longTextWrapper&quot;&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;entryDetailHeader&quot;&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;{{entry.fields.Title}}&lt;/h1&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ul&nbsp;class=&#39;tagCloud&#39;&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&nbsp;atentity=&quot;tag&quot;&nbsp;v-for=&quot;tag&nbsp;in&nbsp;LookupRelatedItems(entry,&nbsp;&#39;Tags&#39;)&quot;&gt;&lt;a&nbsp;v-bind:href=&quot;MakeEntityIntoALink(tag,&nbsp;&#39;Tag&#39;)&quot;&nbsp;v-html=&quot;tag.fields.Name&quot;&gt;&lt;/a&gt;&lt;/li&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ul&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&nbsp;class=&quot;text-muted&nbsp;byline&quot;&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;By\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;span&nbsp;v-for=&quot;author&nbsp;in&nbsp;LookupRelatedItems(entry,&nbsp;&#39;Authors&#39;)&quot;&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{author.fields.Name}}&nbsp;&amp;nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;span&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{entry.createdTime&nbsp;|&nbsp;DatePretty}}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/p&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&lt;!--&nbsp;entry&nbsp;detail&nbsp;header&nbsp;!--&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;entryDetailContentOuter&quot;&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;entryDetailContentInner&quot;&nbsp;v-html=&quot;MarkdownContentToHtml(entry.fields.Content)&quot;&gt;&lt;/div&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;\n&nbsp;&nbsp;&lt;/div&gt;\n\n&nbsp;&nbsp;`</span>,\n&nbsp;&nbsp;props:&nbsp;[<span style=\"color:#a31515;\">&quot;entry&quot;</span>],\n&nbsp;&nbsp;mixins:&nbsp;[AirBlogBase],\n&nbsp;&nbsp;methods:&nbsp;{\n&nbsp;&nbsp;}\n};\n</pre>\n\nEven without knowing anything about Vue.js, you can probably see there's not much *there*, there. Nor should there be. The biggest thing this code does is near the bottom, in the \"MarkdownContentToHtml\" method. It takes whatever I type into an AirTable field and translates markdown to html. That allows me to either blog in plain text or markdown goodness. No html training required. No database training required. Nothing to do, really, aside from click on the web page for the Entries table and add a record. Air Table will even allow me to easily make fancy forms to fill out if people don't like tables. I might try that.\n\nOk, so how about the markdown translation? Surely there's something there, right?\n\nNo. That code is even simpler:\n\n<pre style=\"font-family:Consolas;font-size:13px;color:black;background:white;\">MarkdownContentToHtml(stuff)&nbsp;{\n&nbsp;&nbsp;<span style=\"color:blue;\">if</span>&nbsp;(stuff&nbsp;!=&nbsp;undefined)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">var</span>&nbsp;ret&nbsp;=&nbsp;<span style=\"color:blue;\">this</span>.$md.render(stuff);\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;ret;\n&nbsp;&nbsp;}&nbsp;<span style=\"color:blue;\">else</span>&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;<span style=\"color:#a31515;\">&quot;&quot;</span>;\n&nbsp;&nbsp;}\n}</pre>\n\nIt's really just one line, but I'm being careful about things. All it does is call a library that does the work. There are plenty of libraries out there to plug in here to move markdown to html. I have no desire to write a parsing engine. More to the point, it would never fit into my code budget. And that tells me it's out of scope. It has to be.\n\n## The Post-Mortem\n\nIt is interesting that the system is failing in important ways, like field naming or missing data. Not BS ways, like server credentials. Turns out minimalist code and tools means minimal time spent fighting the tooling and infrastructure.\n\nPeople want fast prototyping tools. Using plain Boostrap code might be a nice mezzanine between CLI demos and a full-UX cornucopia. Easy to do and quick (Some really cool stuff going on in the F# area along these lines as well)\n\nI probably will do a third round of this, maybe in late spring or early summer, after I've used it a bunch more. I want to add commenting -- an engine from somebody else, not something home-grown. I'm sure there will be more to do once I continue exercising the functionality. Definitely need to fix that meta thing.\n\n**The goal is always to walk away from the code**. Code it, have it never fail, have it do something useful, then use the hell out of it. Make a clean getaway. I feel I'm getting close with this fun little AirBlog project. I haven't spent much time at all, and I'm very happy with the return I got for my investment.\n\nThis was hella fun! Watch the video if you'd like more code walkthrough and commentary.\n\n## The Test\n\n- What about building a system that has \"lots of online help available\"? Did we do that?\n- Did we succeed in our mission?\n- Why might a functional approach obviate or drastically change the need for testing?\n\nThanks for hanging out. I'll see you on the Internet!\n\n![](DanielsSignature)\n\n\n\n### Obligatory Promotional Stuff\n\n- [View the source code on GitHub](https://github.com/DanielBMarkham/AirBlog)\n- [Read the book I wrote that informs all of my management, technology, and startup consulting](https://leanpub.com/info-ops?ref=tgb5)\n- [Be a cheapskate, try to avoid buying the book and dive into the free wiki](https://wiki.info-ops.org)","Excerpt":"There's a difference between showing that something can be done and actually doing it.","Approved":true,"Categories":["recD6fV22IR0LSVdB"],"Tags":["recSfRhJdArFwzoIa"],"Media":["recAcRqz9JfqDc8uy"],"StartDate":"2019-01-12T06:00:00.000Z","Blog":["recCGKQBlTWHqrGCu"],"Questions":["recbHiSxqyBiNiuDv","reckKRruy3mvt092D"],"AdminNotes":"Same","TemplateFile":"Entry2.html"},"createdTime":"2019-01-12T15:35:48.000Z"},{"id":"recEUbufzhAvph8K1","fields":{"ID":10,"Authors":["recPwgCd6QGPvd5Fg"],"Title":"The Platform is the Enemy","Content":"\n![](Idiocracy-insertRight)\n\nThe premise of the movie \"Idiocracy\" is simple: in the future mankind has de-evolved into morons. Technology does so much for everybody that nobody knows how it all works anymore.  If we can't fix it, we're all going to die. \n\nOne character asks the other what he likes, The answer is money.\n\n\"I can't believe you like money too!\" the first character says without irony, \"We should hang out!\"\n\nThe gag here is that of course, most everybody likes money. If you reduce all of your life enough, it's just food, sex, money, and looking cool. But who would want to do that? Over the centuries, humans have created massively-complex societies because everybody has different things they like doing and thinking about, but all of that complexity can be reduced to, well, an idiocracy if you try hard enough.\n\nThe movie, however, is just a joke, right? We would never allow that to happen, of course, because that's not the goal of technology. Technology's goal is to make us better, not dumber.\n\nWait one. Is that true? What *is* the goal of technology, anyway? Has anybody ever clearly stated it?\n\nRecently I've heard two goals:\n\n1. The goal of technology is to become a **brain extension**, *helping you to decide what to do* and then helping you get it done.\n2. The goal of technology is to become a **hand-held power tool**, helping you accomplish the things you've *already decided to do*\n\nThat's not the same thing. It turns out the difference is critical.\n\nThe old goal was much simpler: make something people want. I like that goal! It boils down the job of creating technology to the most important parts, need and ability. But was that sustainable? At the end of the day, don't we always end up making some combination of stuff that either helps us *make decisions* or helps us *implement decisions* we've already made? And aren't the two fundamentally incompatible in a future society?\n\nYelp tells you which restaurant to go to. Your GPS automatically takes you there. These are not just different problems, they're different *kinds of problems*. Getting from point A to point B is a matter of math and geometry. Which restaurant is the best tonight? You could spend hours debating that with friends.\n\nIf you reduce anything down enough it becomes idiotic. Each piece of technology we deploy can have the goal of helping us do what we've already decided or helping us decide what to do. The first option leaves the thinking up to us. The second option \"helps\" us think.\n\n<div>\n<div class=\"embed-responsive embed-responsive-16by9\">\n<iframe class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/sZHCVyllnck?rel=0\" allowfullscreen></iframe>\n</div>\n<p class=\"figure-caption text-center text-muted\">\nYou like money too? Wow! I like money! We should hang out!\n</p>\n</div>\n\nHuman brains are not computers. Brains are designed to help us survive and pass on our genes using the minimum amount of energy available. If the GPS takes me where I'm going, I don't need to know how to use maps anymore. So I stop knowing how to use maps. Dump those neurons, they're not needed. If Yelp picks the restaurants for me enough, I stop having nuanced preferences about restaurants. That energy expenditure is no longer needed for survival and reproduction. Dump those neurons. Over time people stop caring about the tiny details of what the difference is between a good and a great restaurant. Yelp handles that.\n\nFor some folks, who cares? It's food. Go eat it. For other folks, picking the right place can be a serious undertaking, worthy of heavy thought and consideration. But if over the years apps like Yelp boil all of that down to four or five stars, then our collective brain is not going to bother with it. Human brains are not computers. If computers do the work for us, we turn off those neurons and save energy.\n\nMeanwhile, on social media there's currently this huge discussion. One bunch of folks says that social media is being overbearing in its censorship of fringe and sometimes hateful opinions. The other bunch of folks says social media is a festering sore full of people who are ugly, hateful, and abusive to those weakest among us. The community has to set standards.\n\nThere doesn't have to be a right and wrong here. I think the crucial thing to to understand that both sides can be entirely correct. We are dealing with the same kind of question.\n\nAll three of these topics -- whether humanity is becoming idiots or not, what the ultimate goal of technology is or should be, and how social media should work -- are intricately related. They're related because of this: *the platform is the enemy*.\n\nThe minute we create a platform for something, whether it's rating movies, tracking projects, or chatting with friends about work, as that platform takes over mindshare, *the assumption becomes that this is a solved problem*.\n\nThe telephone was great. Once we had the telephone, people didn't have to worry about how to talk to people far away anymore. Just pick up the phone. Solved problem.\n\nFacebook is great. Once we had Facebook, people didn't have to worry about how to interact with their friends in a social setting anymore. Just click on the little FB notification (Which seems to be always flashing for some reason to get my attention) Solved problem?\n\nBut these are entirely different things! With the phone, I know who I want to call and why. I push buttons and we are connected. The tech helps me do what I've already decided to do. With Facebook, on the other hand, they get paid to show me things in a certain order. The premise is that I'm waiting (or \"exploring\" if you prefer) until I find something to interact with. The phone is a tool for me to use. I am the tool Facebook is using. I am no longer acting. I am reacting.\n\nAnd even if they weren't paid, interacting with friends socially is an extremely complex affair. What kind of mood are they in? What's their life history? What things are bad to bring up? How does their body language look? Facebook's gimmick is \"Hey, we've reduced all of this to bits and bytes, and we'll even show you what bits and bytes to look at next!\"\n\nSolved problem.\n\nMany, many people do not use the internet, the internet uses them. And this percentage is constantly growing.\n\nJust like the restaurant example, maybe that's fine. I have friends, I have opinions, who cares? It's all idle chat anyway.\n\nThat logic can be true for a bunch of things, but can't be true for *everything*. Otherwise, at some point 100 years from now, we're comparing our life values and end up saying something like \"I like money too\". Everything can't all be reduced down to the lowest common denominator. If it does, we all die.\n\nLife is not a bit or byte, a number to be optimized. It's meaning we define ourselves, in ways we should not quantize. \n\nPlatforms, by their very nature, constantly send out the subtle message: *This is a solved problem. No further effort on your part is required here. No thinking needed.* Platforms resist change. They resist their own evolution by subtly poisoning the discussion before it even starts. \n\nAre restaurant choices more or less important than which movie to watch tonight? There's no right or wrong answer to these questions. We have nice categories like restaurants and movies because currently people consider those things to be different kinds of choices. But why? If the algorithm is king, why shouldn't an algorithm determine both of those things for me? And if it does, why should I bother with worrying about which category is which?\n\nHuman brains are not computers. Let the platform decide. Energy not needed. Dump those neurons.\n\nThis is the more important point. It's not that the platforms turn what might be complex things into simple numbers, or even that they monetize attention. It's that by turning everything into numbers, over time they destroy the distinction between the categories entirely. Platforms are the enemy because they resist analysis in the areas they dominate.\n\nPlatforms turn into settled fact things that should be open for debate, like whether or not Taco Bell is a Mexican restaurant, or whether Milo is an artist with something useful to tell us. (I'm going with \"no\" and \"no\" for both of these.) More dangerously, they do the work of deciding *what categories various things go into*. This category over here is important. That category over there is not. We all make these decisions, and they're all different, and the categories each of us pays careful attention to and loves obsessing about are all different, and because we all have different viewpoints and priorities humankind advances in thousands of directions simultaneously. We survive. We evolve.\n\nTwitter has to decide whether PERSON_X can speak or not because on the Twitter platform, that question has to have a yes or no answer based on the person. Twitter's category for deciding who can speak is \"who is that?\" Is that the right category for social conversations? For political conversations? For conversations about philosophy? Math? Who knows? Who cares? Twitter has decided. Solved problem.\n\nEverybody has different things they like doing and thinking about. Different conversations and audiences have different criteria. Some problems should never be solved. Or rather more directly, some problems should never have a universal answer.\n\nAn aside: We see the same thing in programming. One bunch of folks creates various platforms in order to do the thinking for another bunch of folks. Sometimes these platforms take off and become industry standards. That's quite rare, however. Most of the time we end up training morons who can weakly code against the platform but can't reason effectively about the underlying architecture or reason for the platform to exist in the first place. In our desire to help, we harm the very people we're trying to assist -- by subtly giving them the impression that this is a solved problem. Programmers are just a decade or so ahead of the rest of us.\n\nPopular platforms aren't just a danger economically because they control commerce. They're not just a danger politically because they selectively control and amplify political discourse. They're an extinction-level, existential danger to humans because they prevent people from seriously considering what kinds of categories are important in each of their lives. They resist their own analysis and over time make people dumber. Right now we're skating through the danger because we're harvesting people from less-advanced countries to do our hard-thinking for us. That window is quickly drawing to a close.\n\n![](Terminator-insertLeft)\n\nAI isn't a clear and present danger to our species because we're going to end up fighting the robots like in Terminator. AI is a clear and present danger to our species because it might end up doing exactly what some of us want it to do: become a brain extension.\n\nIf we can't fix this, we're all going to die.\n\nThe Idiocracy starts here. It starts now.\n\n","Excerpt":"Idiocracy is now","Approved":true,"Categories":["recD6fV22IR0LSVdB"],"Tags":["reca8DqcFBPyWFHih","rec8Q7Sn8p6DNLNKJ","receRQaf4IK9F57ip"],"Media":["recdf2rMVu3fw8QHQ"],"StartDate":"2018-12-18T05:00:00.000Z","Blog":["recCGKQBlTWHqrGCu"],"TemplateFile":"Entry2.html"},"createdTime":"2018-12-19T10:48:19.000Z"},{"id":"rec39SaDeZCZjauRo","fields":{"ID":8,"Authors":["recPwgCd6QGPvd5Fg"],"Title":"2000-200-20","Content":"## What if we budgeted our code like we budget everything else?\n\nHow much does a line of code cost?\n\nThe naive answer is that it costs nothing. Bytes are free -- or as close to free as we can come. But it *has* to cost something. After all, it took time to type in, right? So that takes us to our first rule of \"Code Economics\": the cost of a line of code is measured in how much time we spend working with it.\n\nHow much value is in a line of code?\n\nThe naive answer is that the economic value of a line of code is the value of the application (which can be measured various ways) divided by the total line-of-codes (LOC). If you're making $10K per month from a thousand lines of code, each line is bringing in $10.\n\nBut that's obviously not true. We know that the same application can be written using a thousand, ten thousand, or a hundred thousand LOC. The thing the application does for people -- its value -- and the amount of code it takes to write it? They're not related at all. That takes us to the second rule of \"Code Economics\": a line of code has no value whatsoever. It only has value as part of some deployable application. The application is the smallest unit of economic value. (Actually, it's UX flow, but for our purposes today an application supports one UX flow that the user finds value interacting with.)\n\nThe value of an app is more directly measurable. Yes, sometimes it gets more complicated, like if the business purpose of the app is in-app purchases or referrals, but at some point money comes in and we can trace that money back to the app. \n\nHow about the cost of a line of code? Is it just the time we spend typing it in? That's obviously wrong. You have to design it, even if only in your head. You have to test it. You have to deploy it. In fact, once you start thinking about it, there's no limit to the amount of money you can spend on a line of code. If your app is successful, you might spend the rest of your lifetime maintaining that line of code -- looking at it every now and then, tweaking it, changing how it's used. \n\nOf course, most lines of code either work fine or they never provide enough value to make anybody bother with them again. (No economic value = no technical debt) But, assuming you know enough to write an app that has value, each line of code in that app has an potentially-infinite cost.\n\nSo value comes in app-sized chunks while costs is related to the tiny pieces we use to make that app -- and to a large degree this is under our control.\n\nWe have a way in finance of dealing with things that have a limited value but a potentially-unlimited downside. We use a budget. I could go out next month and buy $500 worth of sugar-free bubblegum (I love the stuff), but I don't. I have a budget of $10 per month and I stick to it. That's not because bubblegum is such a huge drain on our finances. It's because little things add up. Without a budget, I have no reasonable way for my wife and I to discuss what's important to us. The budget isn't important. The conversation about values it drives is irreplaceable. \n\n![](CodeEconomicsCenter)\n\n### So why aren't we budgeting our code?\n\nSo far in our discussion, there's really no reason to pick one set of budget numbers over another. Should we limit our applications to a million lines of code? A hundred? We don't know. We can safely say two things. One, given the same value, more code equals more cost. Two, lines-of-code always grows out-of-control the more we poke at it. This leads to the conclusion in the third rule of Code Economics: the only way to limit the costs of solving a problem using programming is to arbitrarily limit the amount of code humans have to mentally-manipulate solving it.\n\nIn a way, this is all common sense. We've been doing it for years. We just haven't been explicit about it. Shared libraries, frameworks, industry standards, and a dozen other things all exist in an effort to limit the amount of code humans have to mentally-manipulate to solve problems.\n\nSo why haven't we succeeded? Why can't most programmers today do their job using four or five lines of code?\n\nBecause lines-of-code always grows the more we poke at it. When the http protocol first appeared, if you wanted a web page? You brought up a terminal and telnetted a small number of commands. Boom, there's your webpage. Now, there are easily 10, maybe 20 various standards and libraries related to what used to be 10 seconds of work. Fifty years from now there will be 40 standards. Same value, more code. Value stays the same, cost of code continues to increase.\n\nI'd like to suggest a completely random rule that I just made up: ***Arbitrarily limit lines of code used to solve a problem and write the app with the goal of never touching it again***\n\nFurthermore, since I'm making stuff up, how about a 2000-200-20 rule for folks writing microservices? Whatever problem you have to solve using microservices, you have 20 microservices to solve it in. Each of those microservices can be written with no more than 200 lines of unique code.\n\nBut wait, I hear you say. That's never going to work! Okay, so among all of those microservices you can have 2,000 lines of code in a shared library. Anything you could ever touch counts as code.\n\nI'm not going to defend my made-up rules aside from saying that budgets always seem arbitrary, and it's not right to create a budget so small that the work can't get done. I don't believe I've done that here -- but I might be wrong! Use other budgets if you like. Hell if I care. But use budgets.\n\nMost programmers probably don't think such a budget is fair, or workable. And I think it's fine. That's fascinating to me and indicates a lack of alignment somewhere in the way we train and socialize programmers.\n\nI'm also suggesting a new thing that has to happen: a code budgeting discussion. Yes, Daniel, your WhizzBang widget is freaking awesome, but it uses 500 lines of code, and that's 500 lines we can't afford right now.\n\nWhoa horsey! Wouldn't I love to hear somebody actually say that! Cost control, in a programming team. Imagine that! And what would come next? I have no idea!\n\nBut I could guess.\n\nDon't some problems require a lot of code? Don't some applications -- most, in fact -- require us to come back to them again and again in order to keep them in alignment with changing user needs?\n\nBoth statements are true. For complex things, we write components. Those components have executing tests that describe them and are used/shared in multiple places. The more they are used/shared, the better they get. That means that components are just another project. It also means that if you don't have multiple teams using your component, you don't have a component. Component creation should be a decision made between teams and involve a completely new project. After all, they have both cost and value.\n\nWhat about coming back to tweak the app as the business needs change? Assuming you have a release that is currently demonstrating value -- a big assumption, by the way -- I think you have to timebox it. Three months of verifying that the app got things mostly right. After that? You write a new app, of course. With the budget we're talking about it's not going to be a huge effort, you've already been living in this space, and it's good to rethink things. Code budgets and timelines prevent [Second System Syndrome](https://en.wikipedia.org/wiki/Second-system_effect). (I think we went off-the-rails somewhere with Second System Syndrome, but I digress)\n\nThere are parts of this essay that are completely made-up. I tried to point those out. There are also parts that are built on decades of experience both coding solutions and watching teams work. What I've seen over-and-over again is that really cool things happen with smart people and creative constraints. Really stupid stuff happens otherwise, because without constraints it's all [bike shedding](https://en.wikipedia.org/wiki/Law_of_triviality).\n\nYou need to start budgeting your code.\n\n![](DanielsSignature)","Excerpt":"Constraints make better solutions. Perhaps thinking of programming in economic terms can help us come up with better constraints that will drive better solutions.","Approved":true,"Categories":["recZLPmdZt7GBUMCG"],"Tags":["reca8DqcFBPyWFHih"],"StartDate":"2018-12-11T05:00:00.000Z","Blog":["recCGKQBlTWHqrGCu"],"TemplateFile":"Entry2.html"},"createdTime":"2018-12-11T10:13:10.000Z"},{"id":"recNvtZLennBcMCHF","fields":{"ID":7,"Authors":["recPwgCd6QGPvd5Fg"],"Title":"Why are Reusable Components so Difficult?","Content":"A couple of weeks ago, Uwe Friedrichsen asked a pretty good question [on his blog](https://blog.codecentric.de/en/2015/10/the-broken-promise-of-re-use/):\n\n*\"...Re-use is the holy grail of IT: whenever a new architectural paradigm comes to IT town, 're-use' is one of the core arguments why to go for that paradigm. The business sales pitch typically goes like this: 'Switching to <insert new paradigm here> will cost some money upfront but due to the re-use it enables it will soon pay back'...In short words: re-use based on any architectural paradigm never worked as promised, the promise was always broken...\"*\n\nHe offers up CORBA, Component-based architectures, EJB, SOA -- then asks if microservices will be any different. Why is the promise of re-use broken? Why can't we create truly reusable code?\n\nThese are great examples, and Friedrichsen does a pretty good job of going over his version of why reuse sucks so bad. You should read his essay. I believe, however, he misses the key point: **classic OO and pure functional programming lead to vastly-different endgames when it comes to reusability because they're based on different assumptions**.\n\nLet's perform an experiment. Holding everything else the same, let's implement the game \"FizzBuzz\" in idiomatic pure FP and OO using F# and C#. That's about as small a code example as I can come up with. First, the F#:\n\n<pre style=\"font-family:Consolas;font-size:13px;color:black;background:white;\"><span style=\"color:blue;\">let</span>&nbsp;(|DivisibleBy|_|)&nbsp;by&nbsp;n&nbsp;=&nbsp;<span style=\"color:blue;\">if</span>&nbsp;n%by=0&nbsp;<span style=\"color:blue;\">then</span>&nbsp;Some&nbsp;DivisibleBy&nbsp;<span style=\"color:blue;\">else</span>&nbsp;None\n<span style=\"color:blue;\">let</span>&nbsp;findMatch&nbsp;=&nbsp;<span style=\"color:blue;\">function</span>\n&nbsp;&nbsp;|&nbsp;DivisibleBy&nbsp;3&nbsp;&amp;&nbsp;DivisibleBy&nbsp;5&nbsp;<span style=\"color:blue;\">-&gt;</span>&nbsp;<span style=\"color:#a31515;\">&quot;FizzBuzz&quot;</span>\n&nbsp;&nbsp;|&nbsp;DivisibleBy&nbsp;3&nbsp;<span style=\"color:blue;\">-&gt;</span>&nbsp;<span style=\"color:#a31515;\">&quot;Fizz&quot;</span>\n&nbsp;&nbsp;|&nbsp;DivisibleBy&nbsp;5&nbsp;<span style=\"color:blue;\">-&gt;</span>&nbsp;<span style=\"color:#a31515;\">&quot;Buzz&quot;</span>\n&nbsp;&nbsp;|&nbsp;_&nbsp;<span style=\"color:blue;\">-&gt;</span>&nbsp;<span style=\"color:#a31515;\">&quot;&quot;</span>\n[&lt;EntryPoint&gt;]\n<span style=\"color:blue;\">let</span>&nbsp;main&nbsp;argv&nbsp;=\n&nbsp;&nbsp;&nbsp;&nbsp;[1..100]&nbsp;|&gt;&nbsp;Seq.map&nbsp;findMatch&nbsp;|&gt;&nbsp;Seq.iteri&nbsp;(printfn&nbsp;<span style=\"color:#a31515;\">&quot;%i&nbsp;%s&quot;</span>)\n&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;<span style=\"color:green;\">//&nbsp;we&#39;re&nbsp;good.&nbsp;Return&nbsp;0&nbsp;to&nbsp;indicate&nbsp;success&nbsp;back&nbsp;to&nbsp;OS</span></pre>\n\nLooks like about a dozen lines of code. Notice these three things:\n\n- It's all in \"pieces\". Nothing is connected to anything. There's a weird thing called DivisibleBy, then there's a chunk of stuff that looks like the main FizzBuzz program. But it's not called from there. Instead, there's this third chunk -- the only \"real\" line of code, which only one line. If you didn't know any better, you wouldn't know what chunk went with what.\n- At the end of the FizzBuzz game, we usually ask, \"What if there is yet another rule?\" In this case, it's obvious from the code that you'd just add something to those DivisibleBy lines in the second chunk. Nothing else would change.\n- Once the pieces are in-place, it looks much more fluid as to how the final line would work. If you're a functional programmer, you realize that the final chunk is really up to the programmer. Here I've done it \"point-free\", which is just piping things from one place to another. But I could have done it several other ways. It really doesn't \"do anything\" aside from evaluate the sequence and print it. How I choose to do that is up to me. I make various choices in order to minimize my cognitive load.\n\nAs an example, for that final line, I might go:\n\n<pre style=\"font-family:Consolas;font-size:13px;color:black;background:white;\"><span style=\"color:blue;\">let</span>&nbsp;fizzBuzz&nbsp;n&nbsp;&nbsp;=&nbsp;n&nbsp;|&gt;&nbsp;Seq.map&nbsp;findMatch&nbsp;|&gt;&nbsp;Seq.iteri&nbsp;(printfn&nbsp;<span style=\"color:#a31515;\">&quot;%i&nbsp;%s&quot;</span>)\n&nbsp;&nbsp;&nbsp;&nbsp;fizzBuzz&nbsp;[1..100]\n</pre>\n\nIn that case, I've collapsed everything down to one token, \"fizzBuzz\" that handles everything but the range of numbers. This allows me to change it up.\n\n<pre style=\"font-family:Consolas;font-size:13px;color:black;background:white;\">fizzBuzz&nbsp;[50..200]\n</pre>\n\n*I know this sounds trivial but it's not*. I made the decisions around the tokens based on anticipated usage in my project. I have wide freedom to join things up -- or not. There is a skill to make tokens that come together in a \"mini-language\" to solve the type of problem in front of me. I don't write the solution; I write the pieces I then can assemble together in various ways to make the solution.\n\nNow let's look at the C# code.\n\n<pre style=\"font-family:Consolas;font-size:13px;color:black;background:white;\"><span style=\"color:green;\">///&nbsp;from&nbsp;https://stackoverflow.com/questions/11764539/writing-fizzbuzz</span>\n<span style=\"color:blue;\">namespace</span>&nbsp;oop\n{\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">class</span>&nbsp;<span style=\"color:#2b91af;\">Program</span>\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">static</span>&nbsp;<span style=\"color:blue;\">void</span>&nbsp;DoFizzBuzz1()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">for</span>&nbsp;(<span style=\"color:blue;\">int</span>&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;=&nbsp;100;&nbsp;i++)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">bool</span>&nbsp;fizz&nbsp;=&nbsp;i&nbsp;%&nbsp;3&nbsp;==&nbsp;0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">bool</span>&nbsp;buzz&nbsp;=&nbsp;i&nbsp;%&nbsp;5&nbsp;==&nbsp;0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">if</span>&nbsp;(fizz&nbsp;&amp;&amp;&nbsp;buzz)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine&nbsp;(i.ToString()&nbsp;+&nbsp;<span style=\"color:#a31515;\">&quot;&nbsp;FizzBuzz&quot;</span>);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">else</span>&nbsp;<span style=\"color:blue;\">if</span>&nbsp;(fizz)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine&nbsp;(i.ToString()&nbsp;+&nbsp;<span style=\"color:#a31515;\">&quot;&nbsp;Fizz&quot;</span>);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">else</span>&nbsp;<span style=\"color:blue;\">if</span>&nbsp;(buzz)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine&nbsp;(i.ToString()&nbsp;+&nbsp;<span style=\"color:#a31515;\">&quot;&nbsp;Buzz&quot;</span>);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">else</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine&nbsp;(i);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">static</span>&nbsp;<span style=\"color:blue;\">void</span>&nbsp;Main(<span style=\"color:blue;\">string</span>[]&nbsp;args)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(<span style=\"color:#a31515;\">&quot;Hello&nbsp;World!&quot;</span>);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoFizzBuzz1();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n</pre>\n\nFor the F# code, I mashed up some code I found on the net. For the C# code, I went to SO and found the top answer to the \"How to do FizzBuzz\" question. That's the fairest way I know how to handle this.\n\nThe C# code is about three times longer. Here's what stands out:\n\n- It's all in a fixed structure. There's a namespace. There's a class. There's a method. Everything has a place and is part of everything else. Things are where they are for a reason.\n- Looking at the structure, it feels like adding new rules makes things more complex. I'm pretty sure a new rule would involve a new line after those two \"bool\" lines with fizz and buzz in them, but then we get into that nested if/else-if/else-if/else structure and something's going to have to change there. Very easy to do, of course My feeling is that adding new rules makes things more complex, where with FP we reached a complexity peak and then it was easy. You might phrase that as \"with FP we started off generic\" On the SO page there was another C# example that offered generic rules, but the other commenters said -- and I agree -- that it looked overly complex. Frankly it looked like a lot of FP crammed into an OOP app. But it was more generic. It's just not the code you'd most likely end up with as a C# programmer. (Remember that code-is-code, and you can just about do anything with anything. The issue today is why coding on average in one paradigm turns out differently than coding on average in another one, not what's possible or what you can or can't do.)\n- It looks much more capable in regards to components and reusability. This is where things get odd. Technically, the C# code *should be* better at components. We have a namespace. That prevents components from getting mixed up. We have a class, \"Program\", that allows us encapsulation and data hiding for our work, preventing consumers from having to worry about how we do things. I've made the method static, but even if we leave it static, an object wrapper clarifies that \"DoFizzBuzz1\" is *this particular version*, perhaps not the same one as one offered by \"Program2\" -- or Program with perhaps a different constructor. If nothing else, in OO things have the appearance of being especially constructed for reuse.\n\nIn the C# code, I'm not managing tokens to create a mini-language, I'm managing structure to keep my code organized. Things go into certain places in OOP, and we have rules to explain when and where they're supposed to go. It's an organization system.\n\nSo on the surface, the C# code should be much better set up to be a reusable component. It's better-organized, after all.\n\nOnly one way to check that. Let's build a component.\n\nCan I drop the C# code into another container, say something to render HTML from a server to a client?\n\nWell, not so much. Everything is stuck in the Main method, and *the Main method is coupled to the DoFizzBuzz1 method*. In addition, the range, 1 to 100, is coupled to the implementation. The class is the way it is because it's coupled to being a C# console app. Most of the difference you see in line count between the two is because the C# app is a template. Everything is stuck together in a tightly-coupled, rigid, yet oddly mutable structure.\n\n<div>\n    <div class=\"embed-responsive embed-responsive-16by9\">\n      <iframe class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/11xLxy-VVSA?rel=0\" allowfullscreen></iframe>\n    </div>\n    <p class=\"figure-caption text-center text-muted\">\n    Code walkthrough. At the end I get a bit mixed up about components and reuse. The topic here is general reuse. Building components to fit into sockets is another situation with its own problems.\n    </p>\n</div>\n\nNone of that is right or wrong, but we run into three or four problems trying to reuse 30 lines of C# that just gets worse the more code we have: *everything is coupled to everything else and mutability makes the linkages impossible to separate*. In fact, because objects are both data and code, **that's by design**. It's supposed to work that way!\n\nWe'd probably want an \"HtmlProgram\" class instead of a Program class. Maybe we'd want an HtmlRenderer class because, dang it, that Html stuff has to go somewhere. FizzBuzz factory? [Enterprise FizzBuzz](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition), anyone?\n\nHow about the F# code? Sure. I've got one line of code in main that I'd need to put somewhere else. Everything else is in the global namespace. Using my second example, if I need to change the range, it's easy -- not coupled to anything. **In pure FP everything is loosely-coupled until the last responsible moment**. Remember, I could juggle those tokens around any way I want right up until that last line. I have wide latitude. OO, on the other hand, requires us to commit to a design early on, as soon as we have enough code and data that indicate it. Otherwise, there's no point in using OO.\n\nIt's important to note that this isn't a C#-bashing essay. One of these isn't better or worse than the other one. They simply solve problems in vastly different ways. The OO code scales up to large, monolithic apps where everything has a place. The FP code scales *out* to tokens that create a DSL that callers can use to do whatever they want using a new language. In OO, I end up with a big honking chunk of data and code that's guaranteed to do exactly what I need (because of testing). In FP, I end up with a new language that I am responsible for to use to create whatever I like (and test as I go.)\n\nBut when the endgame is reuse, say in microservices, the two paradigms lead to drastically different answers. The pure FP paradigm will create reusable code, with added complexity being the responsibility of the consumer in large applications. The OO code will create non-reusable code, with the simplicity of knowing that when you call object-dot-method? The thing that you need will happen. For many, many cases, OO is the better paradigm. It's just never going to make reusable components. Not in a generic sense. You can't get there from here.\n\nOn the other hand, in pure FP you create nothing but reusable components. It's just not clear how they fit together.\n\nMoving to theory, it's even more clear what's happening. All code, no matter the language, is a form of structure that you create in response to a problem. The structure is based on two and only two things: desired future behavior and supplementals (or non-functionals, if you like) Even if you never write anything down, as you type code in you're thinking about whether or not it creates a system that behaves the way you want given all the rules you want to abide by. (Rules being the supplementals)\n\n*In pure FP, I have no supplementals.* That is, there's no SOLID or other things that make me code one way or the other. Everything I write is with the goal of minimizing cognitive complexity while exhibiting the behavior I want. That's it. End of story.\n\n*In OO, the supplementals are more important than the behavior*. Don't believe me? Ever start in with a new framework and have to implement a bunch of interfaces for your objects, even though none of them are called? Why is that? It's because the rules of using the framework are more important than what you're using the framework to do. It has to be that way. That's the core assumption of OO. Things have a place they go in. Frameworks that do a lot of stuff by definition have to have a lot of places for that stuff to go.\n\nIn OO, I am looking outward, building a set of constructs that represent the problem such that I can easily understand and change them. In FP, I am looking inward, trying to use primitives in the simplest transform possible that doesn't involve mutation.\n\nWhen I tried to reuse the C# code, there was a lot of shuffling around for the code to match the new container I was proposing.\n\nIn many ways, good OO is the same as writing down requirements ahead of writing code to fix the problem. It creates a natural, immediate impedance mismatch between what you want -- which you may not know until very late in the game or even after you are done -- and what you can deliver because of all of the other choices you've made.\n\nGood FP projects create reusable components, starting with just 2 lines of code. Good OO projects create understandable code structures, no matter how big the codebase gets. If you want true components and reusability, do straight, pure FP without any supplementals at all, then add whatever you need in at the last responsible moment you can do so. (Insert long discussion here about how the worst thing you can do is mash together paradigms. FP trying to pretend that it is OO can be some of the ugliest code you'll ever see. Pick one and go with it.)\n\nNow you know why.\n\n![Daniels Signature](DanielsSignature)","Excerpt":"We keep trying and trying to build truly reusable components, but we rarely succeed. Why?","Approved":true,"Categories":["recZLPmdZt7GBUMCG"],"Tags":["recIPGRFebYI7QFwM"],"StartDate":"2018-12-06T18:06:00.000Z","Blog":["recCGKQBlTWHqrGCu"],"TemplateFile":"Entry2.html"},"createdTime":"2018-12-06T23:01:19.000Z"},{"id":"recXmHgxSFwTTZy1t","fields":{"ID":6,"Authors":["recPwgCd6QGPvd5Fg"],"Title":"Minimum Blogging Platform","Content":"## What's the minimum code and structure for a blog?\n\n### *(It's less than you think)*\n\nA while back, I was asked to take a look at moving some corporate assets from Wordpress and other content-delivery mechanisms to something more secure and scalable. It was a new finance company, there was a lot of money involved, and when bad content or a crashed site can move millions of dollars, you need to be a lot more careful than the average blogger.\n\nThen there's hacking. Any time there is a server involved, you have a complex system of code and dependencies that hackers can get into and then alter your content. Maybe they send folks to a fake trading site instead of the real one. The attack vectors and scenarios get ugly very quickly. Npm spearfishing, anyone?\n\nSo I brought up the sites and took a look around under the hood. Nothing unusual or complex -- yet. Some Wordpress, some content generation tools, some plugins and libraries here and there. Somebody was using webpack somewhere. Maybe 20 unique pages and 100 or so blog entries? Half-a-dozen COTS plugins. A few domains.\n\nGood news! Whatever they wanted to do, now was the time to do it.\n\nNext? \"How simple and hack-proof can I make this?\"\n\nWatch the video if you'd like the tour. **Spoiler Alert**: The entire thing collapses down to almost nothing while keeping everything you'd ever want in a blog.\n\n<div>\n    <div class=\"embed-responsive embed-responsive-16by9\">\n      <iframe class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/XUjfD55SMxc?rel=0\" allowfullscreen></iframe>\n    </div>\n    <p class=\"figure-caption text-center text-muted\">\n    17-Minute Code Walkthrough\n    </p>\n</div>\n\nIt works anywhere because it's all flat and static, yet it's still interactive. But for the total effect, for the Big Kahuna? You can hook GitHub into AWS so that the entire thing goes serverless -- and has S3/CDN capabilities auto-baked in. For a medium-trafficked-blog, say 20-200k visits? I'm thinking a buck-a-day or so. (Don't quote me.) I know that it autoscales based on traffic. I know that there's nothing for you to do: no servers to update, no security patches, no wondering if you're paying too much.\n\nAll you have to do is, well, blog. Use GitHub if you want to change the design somehow -- which you should be doing no matter how you're delivering content, right?\n\nToo crazy to work? I don't know. You tell me. You're using it right now.\n\nWelcome to the new world!\n\nI could easily push this even further, batch up the few files that are linked in and make it all just one file. Hell, I'd probably do that just to finish up the exercise. The problem: Just like I don't want to get too coupled on the back-end, depending on a certain server or databases services, I don't want to get too coupled on the front-end, either. I might want to upgrade to the latest version of Bootstrap, or Vue.js. It would suck to have to go through all my entries and update every page. Same goes for site-wide theming. Javascript support libraries. Some things should be tightly-coupled. Some things not.\n\nI'm not sure I understand the problem. Ha! What's not to understand about blogging? A great deal, actually. Would I want a lot of template pages for various posts? Would I want a separate page for Categories or Tags?\n\nThere's blogging *in the abstract* and then there's blogging *that I actually do*. These two things can be miles apart! Good architecture is always based on actual usage, not theory, speculation, or patterns you read in a book somewhere. Those are good things, but they're just helpers.\n\nRight now I simply don't know. We find out such things by *using the app*. This is **\"emergent design\"**. I've used blogs my entire life. I know enough to get started -- but the only way to really know is to engage with the problem. So I'll blog some. Have some folks drop by. Figure out what I want. After all, 100 lines of code is pretty easy to modify if I want to later on, when I know more.\n\n**Aside 1**: This was done in just a few days of work while doing other stuff. Compare and contrast that to a typical corporate project, where somebody walks into an office and says \"Hey team! We need to build a new content delivery platform!\" Right now, two weeks later, if we were *lucky*, we'd be hip-deep in database design and framework/IDE spin-up, whereas I'm already moving on to other things. You know, there just might be something to this emergent design stuff. You should check it out! Shameless plug: I wrote [a book describing how to work from taking notes to building code](https://leanpub.com/info-ops?ref=tgbentry1) -- and I'm showing how it all works on the blog.\n\n**Aside 2**: My guess is that with a couple of more weeks of work -- basically pulling out the Vue.js code into reusable components and providing standard views into the data -- and this is e a world-class blogging system. Looking at the simplicity, I really feel the pain for you PHP folks living in WP plug-in land. Oof.\n\nThanks for reading. Let's do it again sometime!\n\n![Daniels Signature](DanielsSignature)\n","Excerpt":"What's the minimal blogging platform (aside from plain html)? You're reading on it!","Approved":true,"Categories":["recZLPmdZt7GBUMCG"],"Tags":["recIPGRFebYI7QFwM"],"StartDate":"2018-12-06T17:50:00.000Z","Blog":["recCGKQBlTWHqrGCu"],"TemplateFile":"Entry2.html"},"createdTime":"2018-12-06T22:49:10.000Z"}]}